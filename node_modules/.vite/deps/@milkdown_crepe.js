import "./chunk-NU6SAH36.js";
import "./chunk-SFBMHIUF.js";
import {
  _t
} from "./chunk-OQJUJ5UK.js";
import {
  history,
  redo,
  undo
} from "./chunk-E2CF34CV.js";
import {
  cr
} from "./chunk-AMUWVZB5.js";
import {
  $e,
  AllSelection,
  DOMParser,
  DOMSerializer,
  H,
  Oe,
  Plugin,
  PluginKey,
  TextSelection,
  X,
  b,
  ce,
  ge,
  getNodeFromSchema,
  h,
  je,
  me,
  q,
  re,
  re2,
  se,
  ue
} from "./chunk-GFK4PW34.js";
import "./chunk-AP6IPAVY.js";
import "./chunk-DP4XHQAG.js";

// node_modules/@milkdown/plugin-history/lib/index.es.js
function t(o, r2) {
  return Object.assign(o, {
    meta: {
      package: "@milkdown/plugin-history",
      ...r2
    }
  }), o;
}
var s = re2("Undo", () => () => undo);
t(s, {
  displayName: "Command<undo>"
});
var m = re2("Redo", () => () => redo);
t(m, {
  displayName: "Command<redo>"
});
var e = h({}, "historyProviderConfig");
t(e, {
  displayName: "Ctx<historyProviderConfig>"
});
var n = ue((o) => history(o.get(e.key)));
t(n, {
  displayName: "Ctx<historyProviderPlugin>"
});
var i = ge("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (o) => {
      const r2 = o.get(je);
      return () => r2.call(s.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (o) => {
      const r2 = o.get(je);
      return () => r2.call(m.key);
    }
  }
});
t(i.ctx, {
  displayName: "KeymapCtx<history>"
});
t(i.shortcuts, {
  displayName: "Keymap<history>"
});
var x = [e, n, i, s, m].flat();

// node_modules/@milkdown/plugin-indent/lib/index.es.js
function u(n2, i2) {
  const { doc: t2, selection: e2 } = n2;
  if (!t2 || !e2 || !(e2 instanceof TextSelection || e2 instanceof AllSelection))
    return n2;
  const { to: c } = e2, o = i2.type === "space" ? Array(i2.size).fill(" ").join("") : "	";
  return n2.insertText(o, c);
}
var r = h({ type: "space", size: 2 }, "indentConfig");
r.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
var s2 = X((n2) => ({
  Tab: (i2, t2) => {
    const e2 = n2.get(r.key), { tr: c } = i2, o = u(c, e2);
    return o.docChanged ? (t2 == null || t2(o), true) : false;
  }
}));
s2.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
var p = [r, s2];

// node_modules/@milkdown/plugin-clipboard/lib/index.es.js
function m2(r2) {
  if (!r2)
    return false;
  if (Array.isArray(r2))
    return r2.length > 1 ? false : m2(r2[0]);
  const e2 = r2.content;
  return e2 ? m2(e2) : r2.type === "text";
}
function L(r2) {
  if (r2.content.childCount === 1) {
    const e2 = r2.content.firstChild;
    if ((e2 == null ? void 0 : e2.type.name) === "text" && e2.marks.length === 0)
      return e2;
    if ((e2 == null ? void 0 : e2.type.name) === "paragraph" && e2.childCount === 1) {
      const o = e2.firstChild;
      if ((o == null ? void 0 : o.type.name) === "text" && o.marks.length === 0)
        return o;
    }
  }
  return false;
}
var W = ue((r2) => {
  const e2 = r2.get(b);
  r2.update(ce, (t2) => ({
    ...t2,
    editable: t2.editable ?? (() => true)
  }));
  const o = new PluginKey("MILKDOWN_CLIPBOARD");
  return new Plugin({
    key: o,
    props: {
      handlePaste: (t2, l2) => {
        var x2, S;
        const d = r2.get(q), i2 = (S = (x2 = t2.props).editable) == null ? void 0 : S.call(x2, t2.state), { clipboardData: a } = l2;
        if (!i2 || !a || t2.state.selection.$from.node().type.spec.code)
          return false;
        const s3 = a.getData("text/plain"), f = a.getData("vscode-editor-data");
        if (f) {
          const n2 = JSON.parse(f), y = n2 == null ? void 0 : n2.mode;
          if (s3 && y) {
            const { tr: c } = t2.state, C = getNodeFromSchema("code_block", e2);
            return c.replaceSelectionWith(C.create({ language: y })).setSelection(
              TextSelection.near(c.doc.resolve(Math.max(0, c.selection.from - 2)))
            ).insertText(s3.replace(/\r\n?/g, `
`)), t2.dispatch(c), true;
          }
        }
        const p3 = a.getData("text/html");
        if (p3.length === 0 && s3.length === 0)
          return false;
        const b2 = DOMParser.fromSchema(e2);
        let u2;
        if (p3.length === 0) {
          const n2 = d(s3);
          if (!n2 || typeof n2 == "string")
            return false;
          u2 = DOMSerializer.fromSchema(e2).serializeFragment(n2.content);
        } else {
          const n2 = document.createElement("template");
          n2.innerHTML = p3, u2 = n2.content.cloneNode(true), n2.remove();
        }
        const h2 = b2.parseSlice(u2), g = L(h2);
        return g ? (t2.dispatch(t2.state.tr.replaceSelectionWith(g, true)), true) : (t2.dispatch(t2.state.tr.replaceSelection(h2)), true);
      },
      clipboardTextSerializer: (t2) => {
        const l2 = r2.get(re);
        if (m2(t2.content.toJSON()))
          return t2.content.textBetween(0, t2.content.size, `

`);
        const i2 = e2.topNodeType.createAndFill(void 0, t2.content);
        return i2 ? l2(i2) : "";
      }
    }
  });
});
W.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};

// node_modules/@milkdown/plugin-trailing/lib/index.es.js
var l = h({
  shouldAppend: (n2) => !(!n2 || ["heading", "paragraph"].includes(n2.type.name)),
  getNode: (n2) => n2.schema.nodes.paragraph.create()
}, "trailingConfig");
l.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
var p2 = ue((n2) => {
  const c = new PluginKey("MILKDOWN_TRAILING"), { shouldAppend: s3, getNode: r2 } = n2.get(l.key), g = new Plugin({
    key: c,
    state: {
      init: (i2, e2) => {
        const t2 = e2.tr.doc.lastChild;
        return s3(t2, e2);
      },
      apply: (i2, e2, t2, o) => {
        if (!i2.docChanged)
          return e2;
        const a = i2.doc.lastChild;
        return s3(a, o);
      }
    },
    appendTransaction: (i2, e2, t2) => {
      const { doc: o, tr: a } = t2, d = r2 == null ? void 0 : r2(t2), u2 = g.getState(t2), m3 = o.content.size;
      if (!(!u2 || !d))
        return a.insert(m3, d);
    }
  });
  return g;
});
p2.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
var P = [l, p2];

// node_modules/@milkdown/crepe/lib/esm/index.js
var CrepeFeature = ((CrepeFeature2) => {
  CrepeFeature2["CodeMirror"] = "code-mirror";
  CrepeFeature2["ListItem"] = "list-item";
  CrepeFeature2["LinkTooltip"] = "link-tooltip";
  CrepeFeature2["Cursor"] = "cursor";
  CrepeFeature2["ImageBlock"] = "image-block";
  CrepeFeature2["BlockEdit"] = "block-edit";
  CrepeFeature2["Toolbar"] = "toolbar";
  CrepeFeature2["Placeholder"] = "placeholder";
  CrepeFeature2["Table"] = "table";
  return CrepeFeature2;
})(CrepeFeature || {});
var defaultFeatures = {
  [
    "cursor"
    /* Cursor */
  ]: true,
  [
    "list-item"
    /* ListItem */
  ]: true,
  [
    "link-tooltip"
    /* LinkTooltip */
  ]: true,
  [
    "image-block"
    /* ImageBlock */
  ]: true,
  [
    "block-edit"
    /* BlockEdit */
  ]: true,
  [
    "placeholder"
    /* Placeholder */
  ]: true,
  [
    "toolbar"
    /* Toolbar */
  ]: true,
  [
    "code-mirror"
    /* CodeMirror */
  ]: true,
  [
    "table"
    /* Table */
  ]: true
};
async function loadFeature(feature, editor, config) {
  switch (feature) {
    case "code-mirror": {
      const { defineFeature } = await import("./index-I5dm1KsK-ASVM6NWO.js");
      return defineFeature(editor, config);
    }
    case "list-item": {
      const { defineFeature } = await import("./index-J3c6JQEf-FBTB2UNS.js");
      return defineFeature(editor, config);
    }
    case "link-tooltip": {
      const { defineFeature } = await import("./index-HHuxH8Dm-TWGF4V3K.js");
      return defineFeature(editor, config);
    }
    case "image-block": {
      const { defineFeature } = await import("./index-X2mjLDJS-K6NBI4KU.js");
      return defineFeature(editor, config);
    }
    case "cursor": {
      const { defineFeature } = await import("./index-6JoGWH2I-VI5Z3SF6.js");
      return defineFeature(editor, config);
    }
    case "block-edit": {
      const { defineFeature } = await import("./index-sE0tYrbc-2P3KEDDP.js");
      return defineFeature(editor, config);
    }
    case "placeholder": {
      const { defineFeature } = await import("./index-CMGDOz11-6OZFQLJG.js");
      return defineFeature(editor, config);
    }
    case "toolbar": {
      const { defineFeature } = await import("./index-eZXAY3yz-5ATD5JBJ.js");
      return defineFeature(editor, config);
    }
    case "table": {
      const { defineFeature } = await import("./index-uThMsyF6-6K4JZQUJ.js");
      return defineFeature(editor, config);
    }
  }
}
var FeaturesCtx = H([], "FeaturesCtx");
function configureFeatures(features) {
  return (ctx) => {
    ctx.inject(FeaturesCtx, features);
  };
}
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _editor;
var _initPromise;
var _rootElement;
var _editable;
var Crepe = class {
  constructor({
    root,
    features = {},
    featureConfigs = {},
    defaultValue = ""
  }) {
    __privateAdd(this, _editor);
    __privateAdd(this, _initPromise);
    __privateAdd(this, _rootElement);
    __privateAdd(this, _editable, true);
    var _a;
    const enabledFeatures = Object.entries({
      ...defaultFeatures,
      ...features
    }).filter(([, enabled]) => enabled).map(([feature]) => feature);
    __privateSet(this, _rootElement, (_a = typeof root === "string" ? document.querySelector(root) : root) != null ? _a : document.body);
    __privateSet(this, _editor, Oe.make().config(configureFeatures(enabledFeatures)).config((ctx) => {
      ctx.set(me, __privateGet(this, _rootElement));
      ctx.set(se, defaultValue);
      ctx.set(ce, {
        editable: () => __privateGet(this, _editable)
      });
      ctx.update(r.key, (value) => ({
        ...value,
        size: 4
      }));
    }).use(cr).use(x).use(p).use(P).use(W).use(_t));
    const promiseList = [];
    enabledFeatures.forEach((feature) => {
      const config = featureConfigs[feature];
      promiseList.push(
        loadFeature(feature, __privateGet(this, _editor), config)
      );
    });
    __privateSet(this, _initPromise, Promise.all(promiseList));
  }
  async create() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).create();
  }
  async destroy() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).destroy();
  }
  get editor() {
    return __privateGet(this, _editor);
  }
  setReadonly(value) {
    __privateSet(this, _editable, !value);
    return this;
  }
  getMarkdown() {
    return __privateGet(this, _editor).action($e());
  }
};
_editor = /* @__PURE__ */ new WeakMap();
_initPromise = /* @__PURE__ */ new WeakMap();
_rootElement = /* @__PURE__ */ new WeakMap();
_editable = /* @__PURE__ */ new WeakMap();
Crepe.Feature = CrepeFeature;
export {
  Crepe,
  CrepeFeature
};
//# sourceMappingURL=@milkdown_crepe.js.map
