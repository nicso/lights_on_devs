import {
  require_lodash
} from "./chunk-4WF63UED.js";
import {
  computePosition,
  flip,
  offset
} from "./chunk-6WIQVOVH.js";
import {
  c,
  clsx_default,
  html,
  useEffect,
  useRef,
  useState
} from "./chunk-457NNR5L.js";
import {
  B
} from "./chunk-AMUWVZB5.js";
import {
  L,
  Plugin,
  PluginKey,
  TextSelection,
  h,
  posToDOMRect,
  ue
} from "./chunk-GFK4PW34.js";
import {
  __toESM
} from "./chunk-DP4XHQAG.js";

// node_modules/@milkdown/plugin-tooltip/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var k = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var n = (o, t, e) => (k(o, t, "read from private field"), e ? e.call(o) : t.get(o));
var l = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
};
var h2 = (o, t, e, s) => (k(o, t, "write to private field"), s ? s.call(o, e) : t.set(o, e), e);
var T = (o, t, e) => (k(o, t, "access private method"), e);
var r;
var d;
var c2;
var a;
var u;
var y;
var C;
var A = class {
  constructor(t) {
    l(this, y);
    l(this, r, void 0);
    l(this, d, void 0);
    l(this, c2, void 0);
    l(this, a, void 0);
    l(this, u, void 0);
    h2(this, c2, false), this.onShow = () => {
    }, this.onHide = () => {
    }, h2(this, u, (e, s) => {
      var P;
      const { state: i, composing: p } = e, { selection: f, doc: w } = i, { ranges: g } = f, $ = Math.min(...g.map((m) => m.$from.pos)), x = Math.max(...g.map((m) => m.$to.pos)), E = s && s.doc.eq(w) && s.selection.eq(f);
      if (n(this, c2) || ((P = e.dom.parentElement) == null || P.appendChild(this.element), h2(this, c2, true)), p || E)
        return;
      if (!n(this, d).call(this, e, s)) {
        this.hide();
        return;
      }
      computePosition({
        getBoundingClientRect: () => posToDOMRect(e, $, x)
      }, this.element, {
        placement: "top",
        middleware: [flip(), offset(n(this, a))]
      }).then(({ x: m, y: _ }) => {
        Object.assign(this.element.style, {
          left: `${m}px`,
          top: `${_}px`
        });
      }), this.show();
    }), this.update = (e, s) => {
      (0, import_lodash.default)(n(this, u), n(this, r))(e, s);
    }, this.destroy = () => {
    }, this.show = (e) => {
      this.element.dataset.show = "true", e && computePosition(e, this.element, {
        placement: "top",
        middleware: [flip(), offset(n(this, a))]
      }).then(({ x: s, y: i }) => {
        Object.assign(this.element.style, {
          left: `${s}px`,
          top: `${i}px`
        });
      }), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = t.content, h2(this, r, t.debounce ?? 200), h2(this, d, t.shouldShow ?? T(this, y, C)), h2(this, a, t.offset), this.element.dataset.show = "false";
  }
};
r = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakSet(), C = function(t) {
  const { doc: e, selection: s } = t.state, { empty: i, from: p, to: f } = s, w = !e.textBetween(p, f).length && t.state.selection instanceof TextSelection, g = this.element.contains(document.activeElement), $ = !t.hasFocus() && !g, x = !t.editable;
  return !($ || i || w || x);
};
function G(o) {
  const t = h({}, `${o}_TOOLTIP_SPEC`), e = ue((i) => {
    const p = i.get(t.key);
    return new Plugin({
      key: new PluginKey(`${o}_TOOLTIP`),
      ...p
    });
  }), s = [t, e];
  return s.key = t.key, s.pluginKey = e.key, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${o}`
  }, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${o}`
  }, s;
}

// node_modules/@milkdown/components/lib/link-tooltip/index.es.js
var import_lodash2 = __toESM(require_lodash());
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a2, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a2, prop, b[prop]);
    }
  return a2;
};
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: __spreadValues$3({
      package: "@milkdown/components"
    }, meta)
  });
  return plugin;
}
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a2, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a2, prop, b[prop]);
    }
  return a2;
};
var defaultState = {
  mode: "preview"
};
var linkTooltipState = h(__spreadValues$2({}, defaultState), "linkTooltipStateCtx");
withMeta(linkTooltipState, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
var defaultAPI = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
};
var linkTooltipAPI = h(__spreadValues$2({}, defaultAPI), "linkTooltipAPICtx");
withMeta(linkTooltipState, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
var defaultConfig = {
  linkIcon: () => "ðŸ”—",
  editButton: () => "âœŽ",
  removeButton: () => "âŒ«",
  confirmButton: () => html`Confirm âŽ`,
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
};
var linkTooltipConfig = h(__spreadValues$2({}, defaultConfig), "linkTooltipConfigCtx");
withMeta(linkTooltipState, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
var linkPreviewTooltip = G("LINK_PREVIEW");
withMeta(linkPreviewTooltip[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
withMeta(linkPreviewTooltip[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
var linkEditTooltip = G("LINK_EDIT");
withMeta(linkEditTooltip[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
withMeta(linkEditTooltip[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function findMarkPosition(mark, node, doc, from, to) {
  let markPos = { start: -1, end: -1 };
  doc.nodesBetween(from, to, (n2, pos) => {
    if (markPos.start > -1)
      return false;
    if (markPos.start === -1 && mark.isInSet(n2.marks) && node === n2) {
      markPos = {
        start: pos,
        end: pos + Math.max(n2.textContent.length, 1)
      };
    }
    return void 0;
  });
  return markPos;
}
function shouldShowPreviewWhenHover(ctx, view, event) {
  const $pos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!$pos)
    return;
  const { pos } = $pos;
  const node = view.state.doc.nodeAt(pos);
  if (!node)
    return;
  const mark = node.marks.find((mark2) => mark2.type === B.mark.type(ctx));
  if (!mark)
    return;
  const key = linkPreviewTooltip.pluginKey();
  if (!key)
    return;
  return { show: true, pos, node, mark };
}
function defIfNotExists(tagName, element) {
  const current = customElements.get(tagName);
  if (current == null) {
    customElements.define(tagName, element);
    return;
  }
  if (current === element)
    return;
  console.warn(`Custom element ${tagName} has been defined before.`);
}
var linkPreviewComponent = ({ config, src, onEdit, onRemove }) => {
  const onClickEditButton = (e) => {
    e.stopPropagation();
    e.preventDefault();
    onEdit == null ? void 0 : onEdit();
  };
  const onClickRemoveButton = (e) => {
    e.stopPropagation();
    e.preventDefault();
    onRemove == null ? void 0 : onRemove();
  };
  const onClickPreview = (e) => {
    e.preventDefault();
    if (navigator.clipboard && src) {
      navigator.clipboard.writeText(src).then(() => {
        config == null ? void 0 : config.onCopyLink(src);
      }).catch((e2) => {
        throw e2;
      });
    }
  };
  return html`
    <host>
      <div class="link-preview" onmousedown=${onClickPreview}>
        <span class="link-icon">
          ${config == null ? void 0 : config.linkIcon()}
        </span>
        <a href=${src} target="_blank" class="link-display">${src}</a>
        <span class="button link-edit-button" onmousedown=${onClickEditButton}>
          ${config == null ? void 0 : config.editButton()}
        </span>
        <span class="button link-remove-button" onmousedown=${onClickRemoveButton}>
          ${config == null ? void 0 : config.removeButton()}
        </span>
      </div>
    </host>
  `;
};
linkPreviewComponent.props = {
  config: Object,
  src: String,
  onEdit: Function,
  onRemove: Function
};
var LinkPreviewElement = c(linkPreviewComponent);
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _content$1;
var _provider$1;
var _slice;
var _hovering;
var _onStateChange;
var _onMouseEnter;
var _onMouseLeave;
var _hide;
var LinkPreviewTooltip = class {
  // get #instance() {
  //   return this.#provider.getInstance()
  // }
  constructor(ctx, view) {
    this.ctx = ctx;
    __privateAdd$1(this, _content$1, new LinkPreviewElement());
    __privateAdd$1(this, _provider$1);
    __privateAdd$1(this, _slice, this.ctx.use(linkTooltipState.key));
    __privateAdd$1(this, _hovering, false);
    __privateAdd$1(this, _onStateChange, ({ mode }) => {
      if (mode === "edit")
        __privateGet$1(this, _hide).call(this);
    });
    __privateAdd$1(this, _onMouseEnter, () => {
      __privateSet$1(this, _hovering, true);
    });
    __privateAdd$1(this, _onMouseLeave, () => {
      __privateSet$1(this, _hovering, false);
    });
    __privateAdd$1(this, _hide, () => {
      __privateGet$1(this, _provider$1).hide();
      __privateGet$1(this, _provider$1).element.removeEventListener("mouseenter", __privateGet$1(this, _onMouseEnter));
      __privateGet$1(this, _provider$1).element.removeEventListener("mouseleave", __privateGet$1(this, _onMouseLeave));
    });
    this.show = (mark, from, to, rect) => {
      __privateGet$1(this, _content$1).config = this.ctx.get(linkTooltipConfig.key);
      __privateGet$1(this, _content$1).src = mark.attrs.href;
      __privateGet$1(this, _content$1).onEdit = () => {
        this.ctx.get(linkTooltipAPI.key).editLink(mark, from, to);
      };
      __privateGet$1(this, _content$1).onRemove = () => {
        this.ctx.get(linkTooltipAPI.key).removeLink(from, to);
        __privateGet$1(this, _hide).call(this);
      };
      __privateGet$1(this, _provider$1).show({
        getBoundingClientRect: () => rect
      });
      __privateGet$1(this, _provider$1).element.addEventListener("mouseenter", __privateGet$1(this, _onMouseEnter));
      __privateGet$1(this, _provider$1).element.addEventListener("mouseleave", __privateGet$1(this, _onMouseLeave));
    };
    this.hide = () => {
      if (__privateGet$1(this, _hovering))
        return;
      __privateGet$1(this, _hide).call(this);
    };
    this.update = () => {
    };
    this.destroy = () => {
      __privateGet$1(this, _slice).off(__privateGet$1(this, _onStateChange));
      __privateGet$1(this, _provider$1).destroy();
      __privateGet$1(this, _content$1).remove();
    };
    __privateSet$1(this, _provider$1, new A({
      debounce: 0,
      content: __privateGet$1(this, _content$1),
      shouldShow: () => false
    }));
    __privateGet$1(this, _provider$1).update(view);
    __privateSet$1(this, _slice, ctx.use(linkTooltipState.key));
    __privateGet$1(this, _slice).on(__privateGet$1(this, _onStateChange));
  }
};
_content$1 = /* @__PURE__ */ new WeakMap();
_provider$1 = /* @__PURE__ */ new WeakMap();
_slice = /* @__PURE__ */ new WeakMap();
_hovering = /* @__PURE__ */ new WeakMap();
_onStateChange = /* @__PURE__ */ new WeakMap();
_onMouseEnter = /* @__PURE__ */ new WeakMap();
_onMouseLeave = /* @__PURE__ */ new WeakMap();
_hide = /* @__PURE__ */ new WeakMap();
defIfNotExists("milkdown-link-preview", LinkPreviewElement);
function configureLinkPreviewTooltip(ctx) {
  let linkPreviewTooltipView;
  const DELAY = 200;
  const onMouseMove = (0, import_lodash2.default)((view, event) => {
    if (!linkPreviewTooltipView)
      return;
    if (!view.hasFocus())
      return;
    const state = ctx.get(linkTooltipState.key);
    if (state.mode === "edit")
      return;
    const result = shouldShowPreviewWhenHover(ctx, view, event);
    if (result) {
      const position = view.state.doc.resolve(result.pos);
      const markPosition = findMarkPosition(result.mark, result.node, view.state.doc, position.before(), position.after());
      const from = markPosition.start;
      const to = markPosition.end;
      linkPreviewTooltipView.show(result.mark, from, to, posToDOMRect(view, from, to));
      return;
    }
    linkPreviewTooltipView.hide();
  }, DELAY);
  const onMouseLeave = () => {
    setTimeout(() => {
      linkPreviewTooltipView == null ? void 0 : linkPreviewTooltipView.hide();
    }, DELAY);
  };
  ctx.set(linkPreviewTooltip.key, {
    props: {
      handleDOMEvents: {
        mousemove: onMouseMove,
        mouseleave: onMouseLeave
      }
    },
    view: (view) => {
      linkPreviewTooltipView = new LinkPreviewTooltip(ctx, view);
      return linkPreviewTooltipView;
    }
  });
}
var linkEditComponent = ({
  src,
  onConfirm,
  onCancel,
  config
}) => {
  const linkInput = useRef();
  const [link, setLink] = useState(src);
  useEffect(() => {
    setLink(src != null ? src : "");
  }, [src]);
  const onConfirmEdit = () => {
    var _a, _b;
    onConfirm == null ? void 0 : onConfirm((_b = (_a = linkInput.current) == null ? void 0 : _a.value) != null ? _b : "");
  };
  const onKeydown = (e) => {
    var _a, _b;
    e.stopPropagation();
    if (e.key === "Enter") {
      onConfirm == null ? void 0 : onConfirm((_b = (_a = linkInput.current) == null ? void 0 : _a.value) != null ? _b : "");
      e.preventDefault();
    }
    if (e.key === "Escape") {
      onCancel == null ? void 0 : onCancel();
      e.preventDefault();
    }
  };
  return html`
    <host>
      <div class="link-edit">
        <input
          class="input-area"
          placeholder=${config == null ? void 0 : config.inputPlaceholder}
          ref=${linkInput}
          onkeydown=${onKeydown}
          oninput=${(e) => setLink(e.target.value)}
          value=${link}
        />
        <span class=${clsx_default("button confirm", !link && "hidden")} onclick=${onConfirmEdit}>
          ${config == null ? void 0 : config.confirmButton()}
        </span>
      </div>
    </host>
  `;
};
linkEditComponent.props = {
  config: Object,
  src: String,
  onConfirm: Function,
  onCancel: Function
};
var LinkEditElement = c(linkEditComponent);
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a2, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b) => __defProps$1(a2, __getOwnPropDescs$1(b));
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _content;
var _provider;
var _data;
var _reset;
var _confirmEdit;
var _enterEditMode;
var defaultData = {
  from: -1,
  to: -1,
  mark: null
};
var LinkEditTooltip = class {
  constructor(ctx, view) {
    this.ctx = ctx;
    __privateAdd(this, _content, new LinkEditElement());
    __privateAdd(this, _provider);
    __privateAdd(this, _data, __spreadValues$1({}, defaultData));
    __privateAdd(this, _reset, () => {
      __privateGet(this, _provider).hide();
      this.ctx.update(linkTooltipState.key, (state) => __spreadProps$1(__spreadValues$1({}, state), {
        mode: "preview"
      }));
      __privateSet(this, _data, __spreadValues$1({}, defaultData));
    });
    __privateAdd(this, _confirmEdit, (href) => {
      const view2 = this.ctx.get(L);
      const { from, to, mark } = __privateGet(this, _data);
      const type = B.type(this.ctx);
      if (mark && mark.attrs.href === href) {
        __privateGet(this, _reset).call(this);
        return;
      }
      const tr = view2.state.tr;
      if (mark)
        tr.removeMark(from, to, mark);
      tr.addMark(from, to, type.create({ href }));
      view2.dispatch(tr);
      __privateGet(this, _reset).call(this);
    });
    __privateAdd(this, _enterEditMode, (value, from, to) => {
      const config = this.ctx.get(linkTooltipConfig.key);
      __privateGet(this, _content).config = config;
      __privateGet(this, _content).src = value;
      this.ctx.update(linkTooltipState.key, (state) => __spreadProps$1(__spreadValues$1({}, state), {
        mode: "edit"
      }));
      const view2 = this.ctx.get(L);
      view2.dispatch(view2.state.tr.setSelection(TextSelection.create(view2.state.doc, from, to)));
      __privateGet(this, _provider).show({
        getBoundingClientRect: () => posToDOMRect(view2, from, to)
      });
      requestAnimationFrame(() => {
        var _a;
        (_a = __privateGet(this, _content).querySelector("input")) == null ? void 0 : _a.focus();
      });
    });
    this.update = (view2) => {
      const { state } = view2;
      const { selection } = state;
      if (!(selection instanceof TextSelection))
        return;
      const { from, to } = selection;
      if (from === __privateGet(this, _data).from && to === __privateGet(this, _data).to)
        return;
      __privateGet(this, _reset).call(this);
    };
    this.destroy = () => {
      __privateGet(this, _provider).destroy();
      __privateGet(this, _content).remove();
    };
    this.addLink = (from, to) => {
      __privateSet(this, _data, {
        from,
        to,
        mark: null
      });
      __privateGet(this, _enterEditMode).call(this, "", from, to);
    };
    this.editLink = (mark, from, to) => {
      __privateSet(this, _data, {
        from,
        to,
        mark
      });
      __privateGet(this, _enterEditMode).call(this, mark.attrs.href, from, to);
    };
    this.removeLink = (from, to) => {
      const view2 = this.ctx.get(L);
      const tr = view2.state.tr;
      tr.removeMark(from, to, B.type(this.ctx));
      view2.dispatch(tr);
      __privateGet(this, _reset).call(this);
    };
    __privateSet(this, _provider, new A({
      content: __privateGet(this, _content),
      debounce: 0,
      shouldShow: () => false
    }));
    __privateGet(this, _provider).onHide = () => {
      __privateGet(this, _content).update().catch((e) => {
        throw e;
      });
      view.dom.focus({ preventScroll: true });
    };
    __privateGet(this, _provider).update(view);
    __privateGet(this, _content).onConfirm = __privateGet(this, _confirmEdit);
    __privateGet(this, _content).onCancel = __privateGet(this, _reset);
  }
};
_content = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_reset = /* @__PURE__ */ new WeakMap();
_confirmEdit = /* @__PURE__ */ new WeakMap();
_enterEditMode = /* @__PURE__ */ new WeakMap();
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
defIfNotExists("milkdown-link-edit", LinkEditElement);
function configureLinkEditTooltip(ctx) {
  let linkEditTooltipView;
  ctx.update(linkTooltipAPI.key, (api) => __spreadProps(__spreadValues({}, api), {
    addLink: (from, to) => {
      linkEditTooltipView == null ? void 0 : linkEditTooltipView.addLink(from, to);
    },
    editLink: (mark, from, to) => {
      linkEditTooltipView == null ? void 0 : linkEditTooltipView.editLink(mark, from, to);
    },
    removeLink: (from, to) => {
      linkEditTooltipView == null ? void 0 : linkEditTooltipView.removeLink(from, to);
    }
  }));
  ctx.set(linkEditTooltip.key, {
    view: (view) => {
      linkEditTooltipView = new LinkEditTooltip(ctx, view);
      return linkEditTooltipView;
    }
  });
}
function configureLinkTooltip(ctx) {
  configureLinkPreviewTooltip(ctx);
  configureLinkEditTooltip(ctx);
}
var linkTooltipPlugin = [linkTooltipState, linkTooltipAPI, linkTooltipConfig, linkPreviewTooltip, linkEditTooltip].flat();

export {
  A,
  G,
  linkTooltipAPI,
  linkTooltipConfig,
  configureLinkTooltip,
  linkTooltipPlugin
};
//# sourceMappingURL=chunk-AHBCO2RX.js.map
