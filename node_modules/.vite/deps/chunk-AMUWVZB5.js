import {
  AddMarkStep,
  Decoration,
  DecorationSet,
  Fragment,
  InputRule,
  L,
  NodeRange,
  Plugin,
  PluginKey,
  Q,
  ReplaceAroundStep,
  ReplaceStep,
  S,
  SKIP,
  Selection,
  Slice,
  TextSelection,
  W,
  canJoin,
  canSplit,
  fe,
  findSelectedNodeOfType,
  ge,
  h,
  he,
  je,
  ke,
  liftTarget,
  markRule,
  oe,
  re2 as re,
  setBlockType,
  textblockTypeInputRule,
  toggleMark,
  ue,
  visit,
  we,
  wrapIn,
  wrappingInputRule,
  ye
} from "./chunk-GFK4PW34.js";

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/@sindresorhus/transliterate/replacements.js
var replacements = [
  // German umlauts
  ["ÃŸ", "ss"],
  ["áºž", "Ss"],
  ["Ã¤", "ae"],
  ["Ã„", "Ae"],
  ["Ã¶", "oe"],
  ["Ã–", "Oe"],
  ["Ã¼", "ue"],
  ["Ãœ", "Ue"],
  // Latin
  ["Ã€", "A"],
  ["Ã", "A"],
  ["Ã‚", "A"],
  ["Ãƒ", "A"],
  ["Ã„", "Ae"],
  ["Ã…", "A"],
  ["Ã†", "AE"],
  ["Ã‡", "C"],
  ["Ãˆ", "E"],
  ["Ã‰", "E"],
  ["ÃŠ", "E"],
  ["Ã‹", "E"],
  ["ÃŒ", "I"],
  ["Ã", "I"],
  ["ÃŽ", "I"],
  ["Ã", "I"],
  ["Ã", "D"],
  ["Ã‘", "N"],
  ["Ã’", "O"],
  ["Ã“", "O"],
  ["Ã”", "O"],
  ["Ã•", "O"],
  ["Ã–", "Oe"],
  ["Å", "O"],
  ["Ã˜", "O"],
  ["Ã™", "U"],
  ["Ãš", "U"],
  ["Ã›", "U"],
  ["Ãœ", "Ue"],
  ["Å°", "U"],
  ["Ã", "Y"],
  ["Ãž", "TH"],
  ["ÃŸ", "ss"],
  ["Ã ", "a"],
  ["Ã¡", "a"],
  ["Ã¢", "a"],
  ["Ã£", "a"],
  ["Ã¤", "ae"],
  ["Ã¥", "a"],
  ["Ã¦", "ae"],
  ["Ã§", "c"],
  ["Ã¨", "e"],
  ["Ã©", "e"],
  ["Ãª", "e"],
  ["Ã«", "e"],
  ["Ã¬", "i"],
  ["Ã­", "i"],
  ["Ã®", "i"],
  ["Ã¯", "i"],
  ["Ã°", "d"],
  ["Ã±", "n"],
  ["Ã²", "o"],
  ["Ã³", "o"],
  ["Ã´", "o"],
  ["Ãµ", "o"],
  ["Ã¶", "oe"],
  ["Å‘", "o"],
  ["Ã¸", "o"],
  ["Ã¹", "u"],
  ["Ãº", "u"],
  ["Ã»", "u"],
  ["Ã¼", "ue"],
  ["Å±", "u"],
  ["Ã½", "y"],
  ["Ã¾", "th"],
  ["Ã¿", "y"],
  ["áºž", "SS"],
  // Vietnamese
  ["Ã ", "a"],
  ["Ã€", "A"],
  ["Ã¡", "a"],
  ["Ã", "A"],
  ["Ã¢", "a"],
  ["Ã‚", "A"],
  ["Ã£", "a"],
  ["Ãƒ", "A"],
  ["Ã¨", "e"],
  ["Ãˆ", "E"],
  ["Ã©", "e"],
  ["Ã‰", "E"],
  ["Ãª", "e"],
  ["ÃŠ", "E"],
  ["Ã¬", "i"],
  ["ÃŒ", "I"],
  ["Ã­", "i"],
  ["Ã", "I"],
  ["Ã²", "o"],
  ["Ã’", "O"],
  ["Ã³", "o"],
  ["Ã“", "O"],
  ["Ã´", "o"],
  ["Ã”", "O"],
  ["Ãµ", "o"],
  ["Ã•", "O"],
  ["Ã¹", "u"],
  ["Ã™", "U"],
  ["Ãº", "u"],
  ["Ãš", "U"],
  ["Ã½", "y"],
  ["Ã", "Y"],
  ["Äƒ", "a"],
  ["Ä‚", "A"],
  ["Ä", "D"],
  ["Ä‘", "d"],
  ["Ä©", "i"],
  ["Ä¨", "I"],
  ["Å©", "u"],
  ["Å¨", "U"],
  ["Æ¡", "o"],
  ["Æ ", "O"],
  ["Æ°", "u"],
  ["Æ¯", "U"],
  ["áº¡", "a"],
  ["áº ", "A"],
  ["áº£", "a"],
  ["áº¢", "A"],
  ["áº¥", "a"],
  ["áº¤", "A"],
  ["áº§", "a"],
  ["áº¦", "A"],
  ["áº©", "a"],
  ["áº¨", "A"],
  ["áº«", "a"],
  ["áºª", "A"],
  ["áº­", "a"],
  ["áº¬", "A"],
  ["áº¯", "a"],
  ["áº®", "A"],
  ["áº±", "a"],
  ["áº°", "A"],
  ["áº³", "a"],
  ["áº²", "A"],
  ["áºµ", "a"],
  ["áº´", "A"],
  ["áº·", "a"],
  ["áº¶", "A"],
  ["áº¹", "e"],
  ["áº¸", "E"],
  ["áº»", "e"],
  ["áºº", "E"],
  ["áº½", "e"],
  ["áº¼", "E"],
  ["áº¿", "e"],
  ["áº¾", "E"],
  ["á»", "e"],
  ["á»€", "E"],
  ["á»ƒ", "e"],
  ["á»‚", "E"],
  ["á»…", "e"],
  ["á»„", "E"],
  ["á»‡", "e"],
  ["á»†", "E"],
  ["á»‰", "i"],
  ["á»ˆ", "I"],
  ["á»‹", "i"],
  ["á»Š", "I"],
  ["á»", "o"],
  ["á»Œ", "O"],
  ["á»", "o"],
  ["á»Ž", "O"],
  ["á»‘", "o"],
  ["á»", "O"],
  ["á»“", "o"],
  ["á»’", "O"],
  ["á»•", "o"],
  ["á»”", "O"],
  ["á»—", "o"],
  ["á»–", "O"],
  ["á»™", "o"],
  ["á»˜", "O"],
  ["á»›", "o"],
  ["á»š", "O"],
  ["á»", "o"],
  ["á»œ", "O"],
  ["á»Ÿ", "o"],
  ["á»ž", "O"],
  ["á»¡", "o"],
  ["á» ", "O"],
  ["á»£", "o"],
  ["á»¢", "O"],
  ["á»¥", "u"],
  ["á»¤", "U"],
  ["á»§", "u"],
  ["á»¦", "U"],
  ["á»©", "u"],
  ["á»¨", "U"],
  ["á»«", "u"],
  ["á»ª", "U"],
  ["á»­", "u"],
  ["á»¬", "U"],
  ["á»¯", "u"],
  ["á»®", "U"],
  ["á»±", "u"],
  ["á»°", "U"],
  ["á»³", "y"],
  ["á»²", "Y"],
  ["á»µ", "y"],
  ["á»´", "Y"],
  ["á»·", "y"],
  ["á»¶", "Y"],
  ["á»¹", "y"],
  ["á»¸", "Y"],
  // Arabic
  ["Ø¡", "e"],
  ["Ø¢", "a"],
  ["Ø£", "a"],
  ["Ø¤", "w"],
  ["Ø¥", "i"],
  ["Ø¦", "y"],
  ["Ø§", "a"],
  ["Ø¨", "b"],
  ["Ø©", "t"],
  ["Øª", "t"],
  ["Ø«", "th"],
  ["Ø¬", "j"],
  ["Ø­", "h"],
  ["Ø®", "kh"],
  ["Ø¯", "d"],
  ["Ø°", "dh"],
  ["Ø±", "r"],
  ["Ø²", "z"],
  ["Ø³", "s"],
  ["Ø´", "sh"],
  ["Øµ", "s"],
  ["Ø¶", "d"],
  ["Ø·", "t"],
  ["Ø¸", "z"],
  ["Ø¹", "e"],
  ["Øº", "gh"],
  ["Ù€", "_"],
  ["Ù", "f"],
  ["Ù‚", "q"],
  ["Ùƒ", "k"],
  ["Ù„", "l"],
  ["Ù…", "m"],
  ["Ù†", "n"],
  ["Ù‡", "h"],
  ["Ùˆ", "w"],
  ["Ù‰", "a"],
  ["ÙŠ", "y"],
  ["ÙŽâ€Ž", "a"],
  ["Ù", "u"],
  ["Ùâ€Ž", "i"],
  ["Ù ", "0"],
  ["Ù¡", "1"],
  ["Ù¢", "2"],
  ["Ù£", "3"],
  ["Ù¤", "4"],
  ["Ù¥", "5"],
  ["Ù¦", "6"],
  ["Ù§", "7"],
  ["Ù¨", "8"],
  ["Ù©", "9"],
  // Persian / Farsi
  ["Ú†", "ch"],
  ["Ú©", "k"],
  ["Ú¯", "g"],
  ["Ù¾", "p"],
  ["Ú˜", "zh"],
  ["ÛŒ", "y"],
  ["Û°", "0"],
  ["Û±", "1"],
  ["Û²", "2"],
  ["Û³", "3"],
  ["Û´", "4"],
  ["Ûµ", "5"],
  ["Û¶", "6"],
  ["Û·", "7"],
  ["Û¸", "8"],
  ["Û¹", "9"],
  // Pashto
  ["Ù¼", "p"],
  ["Ú", "z"],
  ["Ú…", "c"],
  ["Ú‰", "d"],
  ["ïº«", "d"],
  ["ïº­", "r"],
  ["Ú“", "r"],
  ["ïº¯", "z"],
  ["Ú–", "g"],
  ["Úš", "x"],
  ["Ú«", "g"],
  ["Ú¼", "n"],
  ["Û€", "e"],
  ["Û", "e"],
  ["Û", "ai"],
  // Urdu
  ["Ù¹", "t"],
  ["Úˆ", "d"],
  ["Ú‘", "r"],
  ["Úº", "n"],
  ["Û", "h"],
  ["Ú¾", "h"],
  ["Û’", "e"],
  // Russian
  ["Ð", "A"],
  ["Ð°", "a"],
  ["Ð‘", "B"],
  ["Ð±", "b"],
  ["Ð’", "V"],
  ["Ð²", "v"],
  ["Ð“", "G"],
  ["Ð³", "g"],
  ["Ð”", "D"],
  ["Ð´", "d"],
  ["ÑŠÐµ", "ye"],
  ["ÐªÐµ", "Ye"],
  ["ÑŠÐ•", "yE"],
  ["ÐªÐ•", "YE"],
  ["Ð•", "E"],
  ["Ðµ", "e"],
  ["Ð", "Yo"],
  ["Ñ‘", "yo"],
  ["Ð–", "Zh"],
  ["Ð¶", "zh"],
  ["Ð—", "Z"],
  ["Ð·", "z"],
  ["Ð˜", "I"],
  ["Ð¸", "i"],
  ["Ñ‹Ð¹", "iy"],
  ["Ð«Ð¹", "Iy"],
  ["Ð«Ð™", "IY"],
  ["Ñ‹Ð™", "iY"],
  ["Ð™", "Y"],
  ["Ð¹", "y"],
  ["Ðš", "K"],
  ["Ðº", "k"],
  ["Ð›", "L"],
  ["Ð»", "l"],
  ["Ðœ", "M"],
  ["Ð¼", "m"],
  ["Ð", "N"],
  ["Ð½", "n"],
  ["Ðž", "O"],
  ["Ð¾", "o"],
  ["ÐŸ", "P"],
  ["Ð¿", "p"],
  ["Ð ", "R"],
  ["Ñ€", "r"],
  ["Ð¡", "S"],
  ["Ñ", "s"],
  ["Ð¢", "T"],
  ["Ñ‚", "t"],
  ["Ð£", "U"],
  ["Ñƒ", "u"],
  ["Ð¤", "F"],
  ["Ñ„", "f"],
  ["Ð¥", "Kh"],
  ["Ñ…", "kh"],
  ["Ð¦", "Ts"],
  ["Ñ†", "ts"],
  ["Ð§", "Ch"],
  ["Ñ‡", "ch"],
  ["Ð¨", "Sh"],
  ["Ñˆ", "sh"],
  ["Ð©", "Sch"],
  ["Ñ‰", "sch"],
  ["Ðª", ""],
  ["ÑŠ", ""],
  ["Ð«", "Y"],
  ["Ñ‹", "y"],
  ["Ð¬", ""],
  ["ÑŒ", ""],
  ["Ð­", "E"],
  ["Ñ", "e"],
  ["Ð®", "Yu"],
  ["ÑŽ", "yu"],
  ["Ð¯", "Ya"],
  ["Ñ", "ya"],
  // Romanian
  ["Äƒ", "a"],
  ["Ä‚", "A"],
  ["È™", "s"],
  ["È˜", "S"],
  ["È›", "t"],
  ["Èš", "T"],
  ["Å£", "t"],
  ["Å¢", "T"],
  // Turkish
  ["ÅŸ", "s"],
  ["Åž", "S"],
  ["Ã§", "c"],
  ["Ã‡", "C"],
  ["ÄŸ", "g"],
  ["Äž", "G"],
  ["Ä±", "i"],
  ["Ä°", "I"],
  // Armenian
  ["Õ¡", "a"],
  ["Ô±", "A"],
  ["Õ¢", "b"],
  ["Ô²", "B"],
  ["Õ£", "g"],
  ["Ô³", "G"],
  ["Õ¤", "d"],
  ["Ô´", "D"],
  ["Õ¥", "ye"],
  ["Ôµ", "Ye"],
  ["Õ¦", "z"],
  ["Ô¶", "Z"],
  ["Õ§", "e"],
  ["Ô·", "E"],
  ["Õ¨", "y"],
  ["Ô¸", "Y"],
  ["Õ©", "t"],
  ["Ô¹", "T"],
  ["Õª", "zh"],
  ["Ôº", "Zh"],
  ["Õ«", "i"],
  ["Ô»", "I"],
  ["Õ¬", "l"],
  ["Ô¼", "L"],
  ["Õ­", "kh"],
  ["Ô½", "Kh"],
  ["Õ®", "ts"],
  ["Ô¾", "Ts"],
  ["Õ¯", "k"],
  ["Ô¿", "K"],
  ["Õ°", "h"],
  ["Õ€", "H"],
  ["Õ±", "dz"],
  ["Õ", "Dz"],
  ["Õ²", "gh"],
  ["Õ‚", "Gh"],
  ["Õ³", "tch"],
  ["Õƒ", "Tch"],
  ["Õ´", "m"],
  ["Õ„", "M"],
  ["Õµ", "y"],
  ["Õ…", "Y"],
  ["Õ¶", "n"],
  ["Õ†", "N"],
  ["Õ·", "sh"],
  ["Õ‡", "Sh"],
  ["Õ¸", "vo"],
  ["Õˆ", "Vo"],
  ["Õ¹", "ch"],
  ["Õ‰", "Ch"],
  ["Õº", "p"],
  ["ÕŠ", "P"],
  ["Õ»", "j"],
  ["Õ‹", "J"],
  ["Õ¼", "r"],
  ["ÕŒ", "R"],
  ["Õ½", "s"],
  ["Õ", "S"],
  ["Õ¾", "v"],
  ["ÕŽ", "V"],
  ["Õ¿", "t"],
  ["Õ", "T"],
  ["Ö€", "r"],
  ["Õ", "R"],
  ["Ö", "c"],
  ["Õ‘", "C"],
  ["Õ¸Ö‚", "u"],
  ["ÕˆÕ’", "U"],
  ["ÕˆÖ‚", "U"],
  ["Öƒ", "p"],
  ["Õ“", "P"],
  ["Ö„", "q"],
  ["Õ”", "Q"],
  ["Ö…", "o"],
  ["Õ•", "O"],
  ["Ö†", "f"],
  ["Õ–", "F"],
  ["Ö‡", "yev"],
  // Georgian
  ["áƒ", "a"],
  ["áƒ‘", "b"],
  ["áƒ’", "g"],
  ["áƒ“", "d"],
  ["áƒ”", "e"],
  ["áƒ•", "v"],
  ["áƒ–", "z"],
  ["áƒ—", "t"],
  ["áƒ˜", "i"],
  ["áƒ™", "k"],
  ["áƒš", "l"],
  ["áƒ›", "m"],
  ["áƒœ", "n"],
  ["áƒ", "o"],
  ["áƒž", "p"],
  ["áƒŸ", "zh"],
  ["áƒ ", "r"],
  ["áƒ¡", "s"],
  ["áƒ¢", "t"],
  ["áƒ£", "u"],
  ["áƒ¤", "ph"],
  ["áƒ¥", "q"],
  ["áƒ¦", "gh"],
  ["áƒ§", "k"],
  ["áƒ¨", "sh"],
  ["áƒ©", "ch"],
  ["áƒª", "ts"],
  ["áƒ«", "dz"],
  ["áƒ¬", "ts"],
  ["áƒ­", "tch"],
  ["áƒ®", "kh"],
  ["áƒ¯", "j"],
  ["áƒ°", "h"],
  // Czech
  ["Ä", "c"],
  ["Ä", "d"],
  ["Ä›", "e"],
  ["Åˆ", "n"],
  ["Å™", "r"],
  ["Å¡", "s"],
  ["Å¥", "t"],
  ["Å¯", "u"],
  ["Å¾", "z"],
  ["ÄŒ", "C"],
  ["ÄŽ", "D"],
  ["Äš", "E"],
  ["Å‡", "N"],
  ["Å˜", "R"],
  ["Å ", "S"],
  ["Å¤", "T"],
  ["Å®", "U"],
  ["Å½", "Z"],
  // Dhivehi
  ["Þ€", "h"],
  ["Þ", "sh"],
  ["Þ‚", "n"],
  ["Þƒ", "r"],
  ["Þ„", "b"],
  ["Þ…", "lh"],
  ["Þ†", "k"],
  ["Þ‡", "a"],
  ["Þˆ", "v"],
  ["Þ‰", "m"],
  ["ÞŠ", "f"],
  ["Þ‹", "dh"],
  ["ÞŒ", "th"],
  ["Þ", "l"],
  ["ÞŽ", "g"],
  ["Þ", "gn"],
  ["Þ", "s"],
  ["Þ‘", "d"],
  ["Þ’", "z"],
  ["Þ“", "t"],
  ["Þ”", "y"],
  ["Þ•", "p"],
  ["Þ–", "j"],
  ["Þ—", "ch"],
  ["Þ˜", "tt"],
  ["Þ™", "hh"],
  ["Þš", "kh"],
  ["Þ›", "th"],
  ["Þœ", "z"],
  ["Þ", "sh"],
  ["Þž", "s"],
  ["ÞŸ", "d"],
  ["Þ ", "t"],
  ["Þ¡", "z"],
  ["Þ¢", "a"],
  ["Þ£", "gh"],
  ["Þ¤", "q"],
  ["Þ¥", "w"],
  ["Þ¦", "a"],
  ["Þ§", "aa"],
  ["Þ¨", "i"],
  ["Þ©", "ee"],
  ["Þª", "u"],
  ["Þ«", "oo"],
  ["Þ¬", "e"],
  ["Þ­", "ey"],
  ["Þ®", "o"],
  ["Þ¯", "oa"],
  ["Þ°", ""],
  // Greek
  ["Î±", "a"],
  ["Î²", "v"],
  ["Î³", "g"],
  ["Î´", "d"],
  ["Îµ", "e"],
  ["Î¶", "z"],
  ["Î·", "i"],
  ["Î¸", "th"],
  ["Î¹", "i"],
  ["Îº", "k"],
  ["Î»", "l"],
  ["Î¼", "m"],
  ["Î½", "n"],
  ["Î¾", "ks"],
  ["Î¿", "o"],
  ["Ï€", "p"],
  ["Ï", "r"],
  ["Ïƒ", "s"],
  ["Ï„", "t"],
  ["Ï…", "y"],
  ["Ï†", "f"],
  ["Ï‡", "x"],
  ["Ïˆ", "ps"],
  ["Ï‰", "o"],
  ["Î¬", "a"],
  ["Î­", "e"],
  ["Î¯", "i"],
  ["ÏŒ", "o"],
  ["Ï", "y"],
  ["Î®", "i"],
  ["ÏŽ", "o"],
  ["Ï‚", "s"],
  ["ÏŠ", "i"],
  ["Î°", "y"],
  ["Ï‹", "y"],
  ["Î", "i"],
  ["Î‘", "A"],
  ["Î’", "B"],
  ["Î“", "G"],
  ["Î”", "D"],
  ["Î•", "E"],
  ["Î–", "Z"],
  ["Î—", "I"],
  ["Î˜", "TH"],
  ["Î™", "I"],
  ["Îš", "K"],
  ["Î›", "L"],
  ["Îœ", "M"],
  ["Î", "N"],
  ["Îž", "KS"],
  ["ÎŸ", "O"],
  ["Î ", "P"],
  ["Î¡", "R"],
  ["Î£", "S"],
  ["Î¤", "T"],
  ["Î¥", "Y"],
  ["Î¦", "F"],
  ["Î§", "X"],
  ["Î¨", "PS"],
  ["Î©", "O"],
  ["Î†", "A"],
  ["Îˆ", "E"],
  ["ÎŠ", "I"],
  ["ÎŒ", "O"],
  ["ÎŽ", "Y"],
  ["Î‰", "I"],
  ["Î", "O"],
  ["Îª", "I"],
  ["Î«", "Y"],
  // Disabled as it conflicts with German and Latin.
  // Hungarian
  // ['Ã¤', 'a'],
  // ['Ã„', 'A'],
  // ['Ã¶', 'o'],
  // ['Ã–', 'O'],
  // ['Ã¼', 'u'],
  // ['Ãœ', 'U'],
  // ['Å±', 'u'],
  // ['Å°', 'U'],
  // Latvian
  ["Ä", "a"],
  ["Ä“", "e"],
  ["Ä£", "g"],
  ["Ä«", "i"],
  ["Ä·", "k"],
  ["Ä¼", "l"],
  ["Å†", "n"],
  ["Å«", "u"],
  ["Ä€", "A"],
  ["Ä’", "E"],
  ["Ä¢", "G"],
  ["Äª", "I"],
  ["Ä¶", "K"],
  ["Ä»", "L"],
  ["Å…", "N"],
  ["Åª", "U"],
  ["Ä", "c"],
  ["Å¡", "s"],
  ["Å¾", "z"],
  ["ÄŒ", "C"],
  ["Å ", "S"],
  ["Å½", "Z"],
  // Lithuanian
  ["Ä…", "a"],
  ["Ä", "c"],
  ["Ä™", "e"],
  ["Ä—", "e"],
  ["Ä¯", "i"],
  ["Å¡", "s"],
  ["Å³", "u"],
  ["Å«", "u"],
  ["Å¾", "z"],
  ["Ä„", "A"],
  ["ÄŒ", "C"],
  ["Ä˜", "E"],
  ["Ä–", "E"],
  ["Ä®", "I"],
  ["Å ", "S"],
  ["Å²", "U"],
  ["Åª", "U"],
  // Macedonian
  ["ÐŒ", "Kj"],
  ["Ñœ", "kj"],
  ["Ð‰", "Lj"],
  ["Ñ™", "lj"],
  ["ÐŠ", "Nj"],
  ["Ñš", "nj"],
  ["Ð¢Ñ", "Ts"],
  ["Ñ‚Ñ", "ts"],
  // Polish
  ["Ä…", "a"],
  ["Ä‡", "c"],
  ["Ä™", "e"],
  ["Å‚", "l"],
  ["Å„", "n"],
  ["Å›", "s"],
  ["Åº", "z"],
  ["Å¼", "z"],
  ["Ä„", "A"],
  ["Ä†", "C"],
  ["Ä˜", "E"],
  ["Å", "L"],
  ["Åƒ", "N"],
  ["Åš", "S"],
  ["Å¹", "Z"],
  ["Å»", "Z"],
  // Disabled as it conflicts with Vietnamese.
  // Serbian
  // ['Ñ™', 'lj'],
  // ['Ñš', 'nj'],
  // ['Ð‰', 'Lj'],
  // ['ÐŠ', 'Nj'],
  // ['Ä‘', 'dj'],
  // ['Ä', 'Dj'],
  // ['Ñ’', 'dj'],
  // ['Ñ˜', 'j'],
  // ['Ñ›', 'c'],
  // ['ÑŸ', 'dz'],
  // ['Ð‚', 'Dj'],
  // ['Ðˆ', 'j'],
  // ['Ð‹', 'C'],
  // ['Ð', 'Dz'],
  // Disabled as it conflicts with German and Latin.
  // Slovak
  // ['Ã¤', 'a'],
  // ['Ã„', 'A'],
  // ['Ä¾', 'l'],
  // ['Äº', 'l'],
  // ['Å•', 'r'],
  // ['Ä½', 'L'],
  // ['Ä¹', 'L'],
  // ['Å”', 'R'],
  // Disabled as it conflicts with German and Latin.
  // Swedish
  // ['Ã¥', 'o'],
  // ['Ã…', 'o'],
  // ['Ã¤', 'a'],
  // ['Ã„', 'A'],
  // ['Ã«', 'e'],
  // ['Ã‹', 'E'],
  // ['Ã¶', 'o'],
  // ['Ã–', 'O'],
  // Ukrainian
  ["Ð„", "Ye"],
  ["Ð†", "I"],
  ["Ð‡", "Yi"],
  ["Ò", "G"],
  ["Ñ”", "ye"],
  ["Ñ–", "i"],
  ["Ñ—", "yi"],
  ["Ò‘", "g"],
  // Dutch
  ["Ä²", "IJ"],
  ["Ä³", "ij"],
  // Danish
  // ['Ã†', 'Ae'],
  // ['Ã˜', 'Oe'],
  // ['Ã…', 'Aa'],
  // ['Ã¦', 'ae'],
  // ['Ã¸', 'oe'],
  // ['Ã¥', 'aa']
  // Currencies
  ["Â¢", "c"],
  ["Â¥", "Y"],
  ["ß¿", "b"],
  ["à§³", "t"],
  ["à«±", "Bo"],
  ["à¸¿", "B"],
  ["â‚ ", "CE"],
  ["â‚¡", "C"],
  ["â‚¢", "Cr"],
  ["â‚£", "F"],
  ["â‚¥", "m"],
  ["â‚¦", "N"],
  ["â‚§", "Pt"],
  ["â‚¨", "Rs"],
  ["â‚©", "W"],
  ["â‚«", "s"],
  ["â‚¬", "E"],
  ["â‚­", "K"],
  ["â‚®", "T"],
  ["â‚¯", "Dp"],
  ["â‚°", "S"],
  ["â‚±", "P"],
  ["â‚²", "G"],
  ["â‚³", "A"],
  ["â‚´", "S"],
  ["â‚µ", "C"],
  ["â‚¶", "tt"],
  ["â‚·", "S"],
  ["â‚¸", "T"],
  ["â‚¹", "R"],
  ["â‚º", "L"],
  ["â‚½", "P"],
  ["â‚¿", "B"],
  ["ï¹©", "$"],
  ["ï¿ ", "c"],
  ["ï¿¥", "Y"],
  ["ï¿¦", "W"],
  // Latin
  ["ð€", "A"],
  ["ð", "B"],
  ["ð‚", "C"],
  ["ðƒ", "D"],
  ["ð„", "E"],
  ["ð…", "F"],
  ["ð†", "G"],
  ["ð‡", "H"],
  ["ðˆ", "I"],
  ["ð‰", "J"],
  ["ðŠ", "K"],
  ["ð‹", "L"],
  ["ðŒ", "M"],
  ["ð", "N"],
  ["ðŽ", "O"],
  ["ð", "P"],
  ["ð", "Q"],
  ["ð‘", "R"],
  ["ð’", "S"],
  ["ð“", "T"],
  ["ð”", "U"],
  ["ð•", "V"],
  ["ð–", "W"],
  ["ð—", "X"],
  ["ð˜", "Y"],
  ["ð™", "Z"],
  ["ðš", "a"],
  ["ð›", "b"],
  ["ðœ", "c"],
  ["ð", "d"],
  ["ðž", "e"],
  ["ðŸ", "f"],
  ["ð ", "g"],
  ["ð¡", "h"],
  ["ð¢", "i"],
  ["ð£", "j"],
  ["ð¤", "k"],
  ["ð¥", "l"],
  ["ð¦", "m"],
  ["ð§", "n"],
  ["ð¨", "o"],
  ["ð©", "p"],
  ["ðª", "q"],
  ["ð«", "r"],
  ["ð¬", "s"],
  ["ð­", "t"],
  ["ð®", "u"],
  ["ð¯", "v"],
  ["ð°", "w"],
  ["ð±", "x"],
  ["ð²", "y"],
  ["ð³", "z"],
  ["ð´", "A"],
  ["ðµ", "B"],
  ["ð¶", "C"],
  ["ð·", "D"],
  ["ð¸", "E"],
  ["ð¹", "F"],
  ["ðº", "G"],
  ["ð»", "H"],
  ["ð¼", "I"],
  ["ð½", "J"],
  ["ð¾", "K"],
  ["ð¿", "L"],
  ["ð‘€", "M"],
  ["ð‘", "N"],
  ["ð‘‚", "O"],
  ["ð‘ƒ", "P"],
  ["ð‘„", "Q"],
  ["ð‘…", "R"],
  ["ð‘†", "S"],
  ["ð‘‡", "T"],
  ["ð‘ˆ", "U"],
  ["ð‘‰", "V"],
  ["ð‘Š", "W"],
  ["ð‘‹", "X"],
  ["ð‘Œ", "Y"],
  ["ð‘", "Z"],
  ["ð‘Ž", "a"],
  ["ð‘", "b"],
  ["ð‘", "c"],
  ["ð‘‘", "d"],
  ["ð‘’", "e"],
  ["ð‘“", "f"],
  ["ð‘”", "g"],
  ["ð‘–", "i"],
  ["ð‘—", "j"],
  ["ð‘˜", "k"],
  ["ð‘™", "l"],
  ["ð‘š", "m"],
  ["ð‘›", "n"],
  ["ð‘œ", "o"],
  ["ð‘", "p"],
  ["ð‘ž", "q"],
  ["ð‘Ÿ", "r"],
  ["ð‘ ", "s"],
  ["ð‘¡", "t"],
  ["ð‘¢", "u"],
  ["ð‘£", "v"],
  ["ð‘¤", "w"],
  ["ð‘¥", "x"],
  ["ð‘¦", "y"],
  ["ð‘§", "z"],
  ["ð‘¨", "A"],
  ["ð‘©", "B"],
  ["ð‘ª", "C"],
  ["ð‘«", "D"],
  ["ð‘¬", "E"],
  ["ð‘­", "F"],
  ["ð‘®", "G"],
  ["ð‘¯", "H"],
  ["ð‘°", "I"],
  ["ð‘±", "J"],
  ["ð‘²", "K"],
  ["ð‘³", "L"],
  ["ð‘´", "M"],
  ["ð‘µ", "N"],
  ["ð‘¶", "O"],
  ["ð‘·", "P"],
  ["ð‘¸", "Q"],
  ["ð‘¹", "R"],
  ["ð‘º", "S"],
  ["ð‘»", "T"],
  ["ð‘¼", "U"],
  ["ð‘½", "V"],
  ["ð‘¾", "W"],
  ["ð‘¿", "X"],
  ["ð’€", "Y"],
  ["ð’", "Z"],
  ["ð’‚", "a"],
  ["ð’ƒ", "b"],
  ["ð’„", "c"],
  ["ð’…", "d"],
  ["ð’†", "e"],
  ["ð’‡", "f"],
  ["ð’ˆ", "g"],
  ["ð’‰", "h"],
  ["ð’Š", "i"],
  ["ð’‹", "j"],
  ["ð’Œ", "k"],
  ["ð’", "l"],
  ["ð’Ž", "m"],
  ["ð’", "n"],
  ["ð’", "o"],
  ["ð’‘", "p"],
  ["ð’’", "q"],
  ["ð’“", "r"],
  ["ð’”", "s"],
  ["ð’•", "t"],
  ["ð’–", "u"],
  ["ð’—", "v"],
  ["ð’˜", "w"],
  ["ð’™", "x"],
  ["ð’š", "y"],
  ["ð’›", "z"],
  ["ð’œ", "A"],
  ["ð’ž", "C"],
  ["ð’Ÿ", "D"],
  ["ð’¢", "g"],
  ["ð’¥", "J"],
  ["ð’¦", "K"],
  ["ð’©", "N"],
  ["ð’ª", "O"],
  ["ð’«", "P"],
  ["ð’¬", "Q"],
  ["ð’®", "S"],
  ["ð’¯", "T"],
  ["ð’°", "U"],
  ["ð’±", "V"],
  ["ð’²", "W"],
  ["ð’³", "X"],
  ["ð’´", "Y"],
  ["ð’µ", "Z"],
  ["ð’¶", "a"],
  ["ð’·", "b"],
  ["ð’¸", "c"],
  ["ð’¹", "d"],
  ["ð’»", "f"],
  ["ð’½", "h"],
  ["ð’¾", "i"],
  ["ð’¿", "j"],
  ["ð“€", "h"],
  ["ð“", "l"],
  ["ð“‚", "m"],
  ["ð“ƒ", "n"],
  ["ð“…", "p"],
  ["ð“†", "q"],
  ["ð“‡", "r"],
  ["ð“ˆ", "s"],
  ["ð“‰", "t"],
  ["ð“Š", "u"],
  ["ð“‹", "v"],
  ["ð“Œ", "w"],
  ["ð“", "x"],
  ["ð“Ž", "y"],
  ["ð“", "z"],
  ["ð“", "A"],
  ["ð“‘", "B"],
  ["ð“’", "C"],
  ["ð““", "D"],
  ["ð“”", "E"],
  ["ð“•", "F"],
  ["ð“–", "G"],
  ["ð“—", "H"],
  ["ð“˜", "I"],
  ["ð“™", "J"],
  ["ð“š", "K"],
  ["ð“›", "L"],
  ["ð“œ", "M"],
  ["ð“", "N"],
  ["ð“ž", "O"],
  ["ð“Ÿ", "P"],
  ["ð“ ", "Q"],
  ["ð“¡", "R"],
  ["ð“¢", "S"],
  ["ð“£", "T"],
  ["ð“¤", "U"],
  ["ð“¥", "V"],
  ["ð“¦", "W"],
  ["ð“§", "X"],
  ["ð“¨", "Y"],
  ["ð“©", "Z"],
  ["ð“ª", "a"],
  ["ð“«", "b"],
  ["ð“¬", "c"],
  ["ð“­", "d"],
  ["ð“®", "e"],
  ["ð“¯", "f"],
  ["ð“°", "g"],
  ["ð“±", "h"],
  ["ð“²", "i"],
  ["ð“³", "j"],
  ["ð“´", "k"],
  ["ð“µ", "l"],
  ["ð“¶", "m"],
  ["ð“·", "n"],
  ["ð“¸", "o"],
  ["ð“¹", "p"],
  ["ð“º", "q"],
  ["ð“»", "r"],
  ["ð“¼", "s"],
  ["ð“½", "t"],
  ["ð“¾", "u"],
  ["ð“¿", "v"],
  ["ð”€", "w"],
  ["ð”", "x"],
  ["ð”‚", "y"],
  ["ð”ƒ", "z"],
  ["ð”„", "A"],
  ["ð”…", "B"],
  ["ð”‡", "D"],
  ["ð”ˆ", "E"],
  ["ð”‰", "F"],
  ["ð”Š", "G"],
  ["ð”", "J"],
  ["ð”Ž", "K"],
  ["ð”", "L"],
  ["ð”", "M"],
  ["ð”‘", "N"],
  ["ð”’", "O"],
  ["ð”“", "P"],
  ["ð””", "Q"],
  ["ð”–", "S"],
  ["ð”—", "T"],
  ["ð”˜", "U"],
  ["ð”™", "V"],
  ["ð”š", "W"],
  ["ð”›", "X"],
  ["ð”œ", "Y"],
  ["ð”ž", "a"],
  ["ð”Ÿ", "b"],
  ["ð” ", "c"],
  ["ð”¡", "d"],
  ["ð”¢", "e"],
  ["ð”£", "f"],
  ["ð”¤", "g"],
  ["ð”¥", "h"],
  ["ð”¦", "i"],
  ["ð”§", "j"],
  ["ð”¨", "k"],
  ["ð”©", "l"],
  ["ð”ª", "m"],
  ["ð”«", "n"],
  ["ð”¬", "o"],
  ["ð”­", "p"],
  ["ð”®", "q"],
  ["ð”¯", "r"],
  ["ð”°", "s"],
  ["ð”±", "t"],
  ["ð”²", "u"],
  ["ð”³", "v"],
  ["ð”´", "w"],
  ["ð”µ", "x"],
  ["ð”¶", "y"],
  ["ð”·", "z"],
  ["ð”¸", "A"],
  ["ð”¹", "B"],
  ["ð”»", "D"],
  ["ð”¼", "E"],
  ["ð”½", "F"],
  ["ð”¾", "G"],
  ["ð•€", "I"],
  ["ð•", "J"],
  ["ð•‚", "K"],
  ["ð•ƒ", "L"],
  ["ð•„", "M"],
  ["ð•†", "N"],
  ["ð•Š", "S"],
  ["ð•‹", "T"],
  ["ð•Œ", "U"],
  ["ð•", "V"],
  ["ð•Ž", "W"],
  ["ð•", "X"],
  ["ð•", "Y"],
  ["ð•’", "a"],
  ["ð•“", "b"],
  ["ð•”", "c"],
  ["ð••", "d"],
  ["ð•–", "e"],
  ["ð•—", "f"],
  ["ð•˜", "g"],
  ["ð•™", "h"],
  ["ð•š", "i"],
  ["ð•›", "j"],
  ["ð•œ", "k"],
  ["ð•", "l"],
  ["ð•ž", "m"],
  ["ð•Ÿ", "n"],
  ["ð• ", "o"],
  ["ð•¡", "p"],
  ["ð•¢", "q"],
  ["ð•£", "r"],
  ["ð•¤", "s"],
  ["ð•¥", "t"],
  ["ð•¦", "u"],
  ["ð•§", "v"],
  ["ð•¨", "w"],
  ["ð•©", "x"],
  ["ð•ª", "y"],
  ["ð•«", "z"],
  ["ð•¬", "A"],
  ["ð•­", "B"],
  ["ð•®", "C"],
  ["ð•¯", "D"],
  ["ð•°", "E"],
  ["ð•±", "F"],
  ["ð•²", "G"],
  ["ð•³", "H"],
  ["ð•´", "I"],
  ["ð•µ", "J"],
  ["ð•¶", "K"],
  ["ð•·", "L"],
  ["ð•¸", "M"],
  ["ð•¹", "N"],
  ["ð•º", "O"],
  ["ð•»", "P"],
  ["ð•¼", "Q"],
  ["ð•½", "R"],
  ["ð•¾", "S"],
  ["ð•¿", "T"],
  ["ð–€", "U"],
  ["ð–", "V"],
  ["ð–‚", "W"],
  ["ð–ƒ", "X"],
  ["ð–„", "Y"],
  ["ð–…", "Z"],
  ["ð–†", "a"],
  ["ð–‡", "b"],
  ["ð–ˆ", "c"],
  ["ð–‰", "d"],
  ["ð–Š", "e"],
  ["ð–‹", "f"],
  ["ð–Œ", "g"],
  ["ð–", "h"],
  ["ð–Ž", "i"],
  ["ð–", "j"],
  ["ð–", "k"],
  ["ð–‘", "l"],
  ["ð–’", "m"],
  ["ð–“", "n"],
  ["ð–”", "o"],
  ["ð–•", "p"],
  ["ð––", "q"],
  ["ð–—", "r"],
  ["ð–˜", "s"],
  ["ð–™", "t"],
  ["ð–š", "u"],
  ["ð–›", "v"],
  ["ð–œ", "w"],
  ["ð–", "x"],
  ["ð–ž", "y"],
  ["ð–Ÿ", "z"],
  ["ð– ", "A"],
  ["ð–¡", "B"],
  ["ð–¢", "C"],
  ["ð–£", "D"],
  ["ð–¤", "E"],
  ["ð–¥", "F"],
  ["ð–¦", "G"],
  ["ð–§", "H"],
  ["ð–¨", "I"],
  ["ð–©", "J"],
  ["ð–ª", "K"],
  ["ð–«", "L"],
  ["ð–¬", "M"],
  ["ð–­", "N"],
  ["ð–®", "O"],
  ["ð–¯", "P"],
  ["ð–°", "Q"],
  ["ð–±", "R"],
  ["ð–²", "S"],
  ["ð–³", "T"],
  ["ð–´", "U"],
  ["ð–µ", "V"],
  ["ð–¶", "W"],
  ["ð–·", "X"],
  ["ð–¸", "Y"],
  ["ð–¹", "Z"],
  ["ð–º", "a"],
  ["ð–»", "b"],
  ["ð–¼", "c"],
  ["ð–½", "d"],
  ["ð–¾", "e"],
  ["ð–¿", "f"],
  ["ð—€", "g"],
  ["ð—", "h"],
  ["ð—‚", "i"],
  ["ð—ƒ", "j"],
  ["ð—„", "k"],
  ["ð—…", "l"],
  ["ð—†", "m"],
  ["ð—‡", "n"],
  ["ð—ˆ", "o"],
  ["ð—‰", "p"],
  ["ð—Š", "q"],
  ["ð—‹", "r"],
  ["ð—Œ", "s"],
  ["ð—", "t"],
  ["ð—Ž", "u"],
  ["ð—", "v"],
  ["ð—", "w"],
  ["ð—‘", "x"],
  ["ð—’", "y"],
  ["ð—“", "z"],
  ["ð—”", "A"],
  ["ð—•", "B"],
  ["ð—–", "C"],
  ["ð——", "D"],
  ["ð—˜", "E"],
  ["ð—™", "F"],
  ["ð—š", "G"],
  ["ð—›", "H"],
  ["ð—œ", "I"],
  ["ð—", "J"],
  ["ð—ž", "K"],
  ["ð—Ÿ", "L"],
  ["ð— ", "M"],
  ["ð—¡", "N"],
  ["ð—¢", "O"],
  ["ð—£", "P"],
  ["ð—¤", "Q"],
  ["ð—¥", "R"],
  ["ð—¦", "S"],
  ["ð—§", "T"],
  ["ð—¨", "U"],
  ["ð—©", "V"],
  ["ð—ª", "W"],
  ["ð—«", "X"],
  ["ð—¬", "Y"],
  ["ð—­", "Z"],
  ["ð—®", "a"],
  ["ð—¯", "b"],
  ["ð—°", "c"],
  ["ð—±", "d"],
  ["ð—²", "e"],
  ["ð—³", "f"],
  ["ð—´", "g"],
  ["ð—µ", "h"],
  ["ð—¶", "i"],
  ["ð—·", "j"],
  ["ð—¸", "k"],
  ["ð—¹", "l"],
  ["ð—º", "m"],
  ["ð—»", "n"],
  ["ð—¼", "o"],
  ["ð—½", "p"],
  ["ð—¾", "q"],
  ["ð—¿", "r"],
  ["ð˜€", "s"],
  ["ð˜", "t"],
  ["ð˜‚", "u"],
  ["ð˜ƒ", "v"],
  ["ð˜„", "w"],
  ["ð˜…", "x"],
  ["ð˜†", "y"],
  ["ð˜‡", "z"],
  ["ð˜ˆ", "A"],
  ["ð˜‰", "B"],
  ["ð˜Š", "C"],
  ["ð˜‹", "D"],
  ["ð˜Œ", "E"],
  ["ð˜", "F"],
  ["ð˜Ž", "G"],
  ["ð˜", "H"],
  ["ð˜", "I"],
  ["ð˜‘", "J"],
  ["ð˜’", "K"],
  ["ð˜“", "L"],
  ["ð˜”", "M"],
  ["ð˜•", "N"],
  ["ð˜–", "O"],
  ["ð˜—", "P"],
  ["ð˜˜", "Q"],
  ["ð˜™", "R"],
  ["ð˜š", "S"],
  ["ð˜›", "T"],
  ["ð˜œ", "U"],
  ["ð˜", "V"],
  ["ð˜ž", "W"],
  ["ð˜Ÿ", "X"],
  ["ð˜ ", "Y"],
  ["ð˜¡", "Z"],
  ["ð˜¢", "a"],
  ["ð˜£", "b"],
  ["ð˜¤", "c"],
  ["ð˜¥", "d"],
  ["ð˜¦", "e"],
  ["ð˜§", "f"],
  ["ð˜¨", "g"],
  ["ð˜©", "h"],
  ["ð˜ª", "i"],
  ["ð˜«", "j"],
  ["ð˜¬", "k"],
  ["ð˜­", "l"],
  ["ð˜®", "m"],
  ["ð˜¯", "n"],
  ["ð˜°", "o"],
  ["ð˜±", "p"],
  ["ð˜²", "q"],
  ["ð˜³", "r"],
  ["ð˜´", "s"],
  ["ð˜µ", "t"],
  ["ð˜¶", "u"],
  ["ð˜·", "v"],
  ["ð˜¸", "w"],
  ["ð˜¹", "x"],
  ["ð˜º", "y"],
  ["ð˜»", "z"],
  ["ð˜¼", "A"],
  ["ð˜½", "B"],
  ["ð˜¾", "C"],
  ["ð˜¿", "D"],
  ["ð™€", "E"],
  ["ð™", "F"],
  ["ð™‚", "G"],
  ["ð™ƒ", "H"],
  ["ð™„", "I"],
  ["ð™…", "J"],
  ["ð™†", "K"],
  ["ð™‡", "L"],
  ["ð™ˆ", "M"],
  ["ð™‰", "N"],
  ["ð™Š", "O"],
  ["ð™‹", "P"],
  ["ð™Œ", "Q"],
  ["ð™", "R"],
  ["ð™Ž", "S"],
  ["ð™", "T"],
  ["ð™", "U"],
  ["ð™‘", "V"],
  ["ð™’", "W"],
  ["ð™“", "X"],
  ["ð™”", "Y"],
  ["ð™•", "Z"],
  ["ð™–", "a"],
  ["ð™—", "b"],
  ["ð™˜", "c"],
  ["ð™™", "d"],
  ["ð™š", "e"],
  ["ð™›", "f"],
  ["ð™œ", "g"],
  ["ð™", "h"],
  ["ð™ž", "i"],
  ["ð™Ÿ", "j"],
  ["ð™ ", "k"],
  ["ð™¡", "l"],
  ["ð™¢", "m"],
  ["ð™£", "n"],
  ["ð™¤", "o"],
  ["ð™¥", "p"],
  ["ð™¦", "q"],
  ["ð™§", "r"],
  ["ð™¨", "s"],
  ["ð™©", "t"],
  ["ð™ª", "u"],
  ["ð™«", "v"],
  ["ð™¬", "w"],
  ["ð™­", "x"],
  ["ð™®", "y"],
  ["ð™¯", "z"],
  ["ð™°", "A"],
  ["ð™±", "B"],
  ["ð™²", "C"],
  ["ð™³", "D"],
  ["ð™´", "E"],
  ["ð™µ", "F"],
  ["ð™¶", "G"],
  ["ð™·", "H"],
  ["ð™¸", "I"],
  ["ð™¹", "J"],
  ["ð™º", "K"],
  ["ð™»", "L"],
  ["ð™¼", "M"],
  ["ð™½", "N"],
  ["ð™¾", "O"],
  ["ð™¿", "P"],
  ["ðš€", "Q"],
  ["ðš", "R"],
  ["ðš‚", "S"],
  ["ðšƒ", "T"],
  ["ðš„", "U"],
  ["ðš…", "V"],
  ["ðš†", "W"],
  ["ðš‡", "X"],
  ["ðšˆ", "Y"],
  ["ðš‰", "Z"],
  ["ðšŠ", "a"],
  ["ðš‹", "b"],
  ["ðšŒ", "c"],
  ["ðš", "d"],
  ["ðšŽ", "e"],
  ["ðš", "f"],
  ["ðš", "g"],
  ["ðš‘", "h"],
  ["ðš’", "i"],
  ["ðš“", "j"],
  ["ðš”", "k"],
  ["ðš•", "l"],
  ["ðš–", "m"],
  ["ðš—", "n"],
  ["ðš˜", "o"],
  ["ðš™", "p"],
  ["ðšš", "q"],
  ["ðš›", "r"],
  ["ðšœ", "s"],
  ["ðš", "t"],
  ["ðšž", "u"],
  ["ðšŸ", "v"],
  ["ðš ", "w"],
  ["ðš¡", "x"],
  ["ðš¢", "y"],
  ["ðš£", "z"],
  // Dotless letters
  ["ðš¤", "l"],
  ["ðš¥", "j"],
  // Greek
  ["ð›¢", "A"],
  ["ð›£", "B"],
  ["ð›¤", "G"],
  ["ð›¥", "D"],
  ["ð›¦", "E"],
  ["ð›§", "Z"],
  ["ð›¨", "I"],
  ["ð›©", "TH"],
  ["ð›ª", "I"],
  ["ð›«", "K"],
  ["ð›¬", "L"],
  ["ð›­", "M"],
  ["ð›®", "N"],
  ["ð›¯", "KS"],
  ["ð›°", "O"],
  ["ð›±", "P"],
  ["ð›²", "R"],
  ["ð›³", "TH"],
  ["ð›´", "S"],
  ["ð›µ", "T"],
  ["ð›¶", "Y"],
  ["ð›·", "F"],
  ["ð›¸", "x"],
  ["ð›¹", "PS"],
  ["ð›º", "O"],
  ["ð›»", "D"],
  ["ð›¼", "a"],
  ["ð›½", "b"],
  ["ð›¾", "g"],
  ["ð›¿", "d"],
  ["ðœ€", "e"],
  ["ðœ", "z"],
  ["ðœ‚", "i"],
  ["ðœƒ", "th"],
  ["ðœ„", "i"],
  ["ðœ…", "k"],
  ["ðœ†", "l"],
  ["ðœ‡", "m"],
  ["ðœˆ", "n"],
  ["ðœ‰", "ks"],
  ["ðœŠ", "o"],
  ["ðœ‹", "p"],
  ["ðœŒ", "r"],
  ["ðœ", "s"],
  ["ðœŽ", "s"],
  ["ðœ", "t"],
  ["ðœ", "y"],
  ["ðœ‘", "f"],
  ["ðœ’", "x"],
  ["ðœ“", "ps"],
  ["ðœ”", "o"],
  ["ðœ•", "d"],
  ["ðœ–", "E"],
  ["ðœ—", "TH"],
  ["ðœ˜", "K"],
  ["ðœ™", "f"],
  ["ðœš", "r"],
  ["ðœ›", "p"],
  ["ðœœ", "A"],
  ["ðœ", "V"],
  ["ðœž", "G"],
  ["ðœŸ", "D"],
  ["ðœ ", "E"],
  ["ðœ¡", "Z"],
  ["ðœ¢", "I"],
  ["ðœ£", "TH"],
  ["ðœ¤", "I"],
  ["ðœ¥", "K"],
  ["ðœ¦", "L"],
  ["ðœ§", "M"],
  ["ðœ¨", "N"],
  ["ðœ©", "KS"],
  ["ðœª", "O"],
  ["ðœ«", "P"],
  ["ðœ¬", "S"],
  ["ðœ­", "TH"],
  ["ðœ®", "S"],
  ["ðœ¯", "T"],
  ["ðœ°", "Y"],
  ["ðœ±", "F"],
  ["ðœ²", "X"],
  ["ðœ³", "PS"],
  ["ðœ´", "O"],
  ["ðœµ", "D"],
  ["ðœ¶", "a"],
  ["ðœ·", "v"],
  ["ðœ¸", "g"],
  ["ðœ¹", "d"],
  ["ðœº", "e"],
  ["ðœ»", "z"],
  ["ðœ¼", "i"],
  ["ðœ½", "th"],
  ["ðœ¾", "i"],
  ["ðœ¿", "k"],
  ["ð€", "l"],
  ["ð", "m"],
  ["ð‚", "n"],
  ["ðƒ", "ks"],
  ["ð„", "o"],
  ["ð…", "p"],
  ["ð†", "r"],
  ["ð‡", "s"],
  ["ðˆ", "s"],
  ["ð‰", "t"],
  ["ðŠ", "y"],
  ["ð‹", "f"],
  ["ðŒ", "x"],
  ["ð", "ps"],
  ["ðŽ", "o"],
  ["ð", "a"],
  ["ð", "e"],
  ["ð‘", "i"],
  ["ð’", "k"],
  ["ð“", "f"],
  ["ð”", "r"],
  ["ð•", "p"],
  ["ð–", "A"],
  ["ð—", "B"],
  ["ð˜", "G"],
  ["ð™", "D"],
  ["ðš", "E"],
  ["ð›", "Z"],
  ["ðœ", "I"],
  ["ð", "TH"],
  ["ðž", "I"],
  ["ðŸ", "K"],
  ["ð ", "L"],
  ["ð¡", "M"],
  ["ð¢", "N"],
  ["ð£", "KS"],
  ["ð¤", "O"],
  ["ð¥", "P"],
  ["ð¦", "R"],
  ["ð§", "TH"],
  ["ð¨", "S"],
  ["ð©", "T"],
  ["ðª", "Y"],
  ["ð«", "F"],
  ["ð¬", "X"],
  ["ð­", "PS"],
  ["ð®", "O"],
  ["ð¯", "D"],
  ["ð°", "a"],
  ["ð±", "v"],
  ["ð²", "g"],
  ["ð³", "d"],
  ["ð´", "e"],
  ["ðµ", "z"],
  ["ð¶", "i"],
  ["ð·", "th"],
  ["ð¸", "i"],
  ["ð¹", "k"],
  ["ðº", "l"],
  ["ð»", "m"],
  ["ð¼", "n"],
  ["ð½", "ks"],
  ["ð¾", "o"],
  ["ð¿", "p"],
  ["ðž€", "r"],
  ["ðž", "s"],
  ["ðž‚", "s"],
  ["ðžƒ", "t"],
  ["ðž„", "y"],
  ["ðž…", "f"],
  ["ðž†", "x"],
  ["ðž‡", "ps"],
  ["ðžˆ", "o"],
  ["ðž‰", "a"],
  ["ðžŠ", "e"],
  ["ðž‹", "i"],
  ["ðžŒ", "k"],
  ["ðž", "f"],
  ["ðžŽ", "r"],
  ["ðž", "p"],
  ["ðž", "A"],
  ["ðž‘", "V"],
  ["ðž’", "G"],
  ["ðž“", "D"],
  ["ðž”", "E"],
  ["ðž•", "Z"],
  ["ðž–", "I"],
  ["ðž—", "TH"],
  ["ðž˜", "I"],
  ["ðž™", "K"],
  ["ðžš", "L"],
  ["ðž›", "M"],
  ["ðžœ", "N"],
  ["ðž", "KS"],
  ["ðžž", "O"],
  ["ðžŸ", "P"],
  ["ðž ", "S"],
  ["ðž¡", "TH"],
  ["ðž¢", "S"],
  ["ðž£", "T"],
  ["ðž¤", "Y"],
  ["ðž¥", "F"],
  ["ðž¦", "X"],
  ["ðž§", "PS"],
  ["ðž¨", "O"],
  ["ðž©", "D"],
  ["ðžª", "av"],
  ["ðž«", "g"],
  ["ðž¬", "d"],
  ["ðž­", "e"],
  ["ðž®", "z"],
  ["ðž¯", "i"],
  ["ðž°", "i"],
  ["ðž±", "th"],
  ["ðž²", "i"],
  ["ðž³", "k"],
  ["ðž´", "l"],
  ["ðžµ", "m"],
  ["ðž¶", "n"],
  ["ðž·", "ks"],
  ["ðž¸", "o"],
  ["ðž¹", "p"],
  ["ðžº", "r"],
  ["ðž»", "s"],
  ["ðž¼", "s"],
  ["ðž½", "t"],
  ["ðž¾", "y"],
  ["ðž¿", "f"],
  ["ðŸ€", "x"],
  ["ðŸ", "ps"],
  ["ðŸ‚", "o"],
  ["ðŸƒ", "a"],
  ["ðŸ„", "e"],
  ["ðŸ…", "i"],
  ["ðŸ†", "k"],
  ["ðŸ‡", "f"],
  ["ðŸˆ", "r"],
  ["ðŸ‰", "p"],
  ["ðŸŠ", "F"],
  ["ðŸ‹", "f"],
  ["â’œ", "(a)"],
  ["â’", "(b)"],
  ["â’ž", "(c)"],
  ["â’Ÿ", "(d)"],
  ["â’ ", "(e)"],
  ["â’¡", "(f)"],
  ["â’¢", "(g)"],
  ["â’£", "(h)"],
  ["â’¤", "(i)"],
  ["â’¥", "(j)"],
  ["â’¦", "(k)"],
  ["â’§", "(l)"],
  ["â’¨", "(m)"],
  ["â’©", "(n)"],
  ["â’ª", "(o)"],
  ["â’«", "(p)"],
  ["â’¬", "(q)"],
  ["â’­", "(r)"],
  ["â’®", "(s)"],
  ["â’¯", "(t)"],
  ["â’°", "(u)"],
  ["â’±", "(v)"],
  ["â’²", "(w)"],
  ["â’³", "(x)"],
  ["â’´", "(y)"],
  ["â’µ", "(z)"],
  ["â’¶", "(A)"],
  ["â’·", "(B)"],
  ["â’¸", "(C)"],
  ["â’¹", "(D)"],
  ["â’º", "(E)"],
  ["â’»", "(F)"],
  ["â’¼", "(G)"],
  ["â’½", "(H)"],
  ["â’¾", "(I)"],
  ["â’¿", "(J)"],
  ["â“€", "(K)"],
  ["â“", "(L)"],
  ["â“ƒ", "(N)"],
  ["â“„", "(O)"],
  ["â“…", "(P)"],
  ["â“†", "(Q)"],
  ["â“‡", "(R)"],
  ["â“ˆ", "(S)"],
  ["â“‰", "(T)"],
  ["â“Š", "(U)"],
  ["â“‹", "(V)"],
  ["â“Œ", "(W)"],
  ["â“", "(X)"],
  ["â“Ž", "(Y)"],
  ["â“", "(Z)"],
  ["â“", "(a)"],
  ["â“‘", "(b)"],
  ["â“’", "(b)"],
  ["â““", "(c)"],
  ["â“”", "(e)"],
  ["â“•", "(f)"],
  ["â“–", "(g)"],
  ["â“—", "(h)"],
  ["â“˜", "(i)"],
  ["â“™", "(j)"],
  ["â“š", "(k)"],
  ["â“›", "(l)"],
  ["â“œ", "(m)"],
  ["â“", "(n)"],
  ["â“ž", "(o)"],
  ["â“Ÿ", "(p)"],
  ["â“ ", "(q)"],
  ["â“¡", "(r)"],
  ["â“¢", "(s)"],
  ["â“£", "(t)"],
  ["â“¤", "(u)"],
  ["â“¥", "(v)"],
  ["â“¦", "(w)"],
  ["â“§", "(x)"],
  ["â“¨", "(y)"],
  ["â“©", "(z)"],
  // Maltese
  ["ÄŠ", "C"],
  ["Ä‹", "c"],
  ["Ä ", "G"],
  ["Ä¡", "g"],
  ["Ä¦", "H"],
  ["Ä§", "h"],
  ["Å»", "Z"],
  ["Å¼", "z"],
  // Numbers
  ["ðŸŽ", "0"],
  ["ðŸ", "1"],
  ["ðŸ", "2"],
  ["ðŸ‘", "3"],
  ["ðŸ’", "4"],
  ["ðŸ“", "5"],
  ["ðŸ”", "6"],
  ["ðŸ•", "7"],
  ["ðŸ–", "8"],
  ["ðŸ—", "9"],
  ["ðŸ˜", "0"],
  ["ðŸ™", "1"],
  ["ðŸš", "2"],
  ["ðŸ›", "3"],
  ["ðŸœ", "4"],
  ["ðŸ", "5"],
  ["ðŸž", "6"],
  ["ðŸŸ", "7"],
  ["ðŸ ", "8"],
  ["ðŸ¡", "9"],
  ["ðŸ¢", "0"],
  ["ðŸ£", "1"],
  ["ðŸ¤", "2"],
  ["ðŸ¥", "3"],
  ["ðŸ¦", "4"],
  ["ðŸ§", "5"],
  ["ðŸ¨", "6"],
  ["ðŸ©", "7"],
  ["ðŸª", "8"],
  ["ðŸ«", "9"],
  ["ðŸ¬", "0"],
  ["ðŸ­", "1"],
  ["ðŸ®", "2"],
  ["ðŸ¯", "3"],
  ["ðŸ°", "4"],
  ["ðŸ±", "5"],
  ["ðŸ²", "6"],
  ["ðŸ³", "7"],
  ["ðŸ´", "8"],
  ["ðŸµ", "9"],
  ["ðŸ¶", "0"],
  ["ðŸ·", "1"],
  ["ðŸ¸", "2"],
  ["ðŸ¹", "3"],
  ["ðŸº", "4"],
  ["ðŸ»", "5"],
  ["ðŸ¼", "6"],
  ["ðŸ½", "7"],
  ["ðŸ¾", "8"],
  ["ðŸ¿", "9"],
  ["â‘ ", "1"],
  ["â‘¡", "2"],
  ["â‘¢", "3"],
  ["â‘£", "4"],
  ["â‘¤", "5"],
  ["â‘¥", "6"],
  ["â‘¦", "7"],
  ["â‘§", "8"],
  ["â‘¨", "9"],
  ["â‘©", "10"],
  ["â‘ª", "11"],
  ["â‘«", "12"],
  ["â‘¬", "13"],
  ["â‘­", "14"],
  ["â‘®", "15"],
  ["â‘¯", "16"],
  ["â‘°", "17"],
  ["â‘±", "18"],
  ["â‘²", "19"],
  ["â‘³", "20"],
  ["â‘´", "1"],
  ["â‘µ", "2"],
  ["â‘¶", "3"],
  ["â‘·", "4"],
  ["â‘¸", "5"],
  ["â‘¹", "6"],
  ["â‘º", "7"],
  ["â‘»", "8"],
  ["â‘¼", "9"],
  ["â‘½", "10"],
  ["â‘¾", "11"],
  ["â‘¿", "12"],
  ["â’€", "13"],
  ["â’", "14"],
  ["â’‚", "15"],
  ["â’ƒ", "16"],
  ["â’„", "17"],
  ["â’…", "18"],
  ["â’†", "19"],
  ["â’‡", "20"],
  ["â’ˆ", "1."],
  ["â’‰", "2."],
  ["â’Š", "3."],
  ["â’‹", "4."],
  ["â’Œ", "5."],
  ["â’", "6."],
  ["â’Ž", "7."],
  ["â’", "8."],
  ["â’", "9."],
  ["â’‘", "10."],
  ["â’’", "11."],
  ["â’“", "12."],
  ["â’”", "13."],
  ["â’•", "14."],
  ["â’–", "15."],
  ["â’—", "16."],
  ["â’˜", "17."],
  ["â’™", "18."],
  ["â’š", "19."],
  ["â’›", "20."],
  ["â“ª", "0"],
  ["â“«", "11"],
  ["â“¬", "12"],
  ["â“­", "13"],
  ["â“®", "14"],
  ["â“¯", "15"],
  ["â“°", "16"],
  ["â“±", "17"],
  ["â“²", "18"],
  ["â“³", "19"],
  ["â“´", "20"],
  ["â“µ", "1"],
  ["â“¶", "2"],
  ["â“·", "3"],
  ["â“¸", "4"],
  ["â“¹", "5"],
  ["â“º", "6"],
  ["â“»", "7"],
  ["â“¼", "8"],
  ["â“½", "9"],
  ["â“¾", "10"],
  ["â“¿", "0"],
  // Punctuation
  ["ðŸ™°", "&"],
  ["ðŸ™±", "&"],
  ["ðŸ™²", "&"],
  ["ðŸ™³", "&"],
  ["ðŸ™´", "&"],
  ["ðŸ™µ", "&"],
  ["ðŸ™¶", '"'],
  ["ðŸ™·", '"'],
  ["ðŸ™¸", '"'],
  ["â€½", "?!"],
  ["ðŸ™¹", "?!"],
  ["ðŸ™º", "?!"],
  ["ðŸ™»", "?!"],
  ["ðŸ™¼", "/"],
  ["ðŸ™½", "\\"],
  // Alchemy
  ["ðŸœ‡", "AR"],
  ["ðŸœˆ", "V"],
  ["ðŸœ‰", "V"],
  ["ðŸœ†", "VR"],
  ["ðŸœ…", "VF"],
  ["ðŸœ©", "2"],
  ["ðŸœª", "5"],
  ["ðŸ¡", "f"],
  ["ðŸ¢", "W"],
  ["ðŸ£", "U"],
  ["ðŸ§", "V"],
  ["ðŸ¨", "T"],
  ["ðŸª", "V"],
  ["ðŸ«", "MB"],
  ["ðŸ¬", "VB"],
  ["ðŸ²", "3B"],
  ["ðŸ³", "3B"],
  // Emojis
  ["ðŸ’¯", "100"],
  ["ðŸ”™", "BACK"],
  ["ðŸ”š", "END"],
  ["ðŸ”›", "ON!"],
  ["ðŸ”œ", "SOON"],
  ["ðŸ”", "TOP"],
  ["ðŸ”ž", "18"],
  ["ðŸ”¤", "abc"],
  ["ðŸ” ", "ABCD"],
  ["ðŸ”¡", "abcd"],
  ["ðŸ”¢", "1234"],
  ["ðŸ”£", "T&@%"],
  ["#ï¸âƒ£", "#"],
  ["*ï¸âƒ£", "*"],
  ["0ï¸âƒ£", "0"],
  ["1ï¸âƒ£", "1"],
  ["2ï¸âƒ£", "2"],
  ["3ï¸âƒ£", "3"],
  ["4ï¸âƒ£", "4"],
  ["5ï¸âƒ£", "5"],
  ["6ï¸âƒ£", "6"],
  ["7ï¸âƒ£", "7"],
  ["8ï¸âƒ£", "8"],
  ["9ï¸âƒ£", "9"],
  ["ðŸ”Ÿ", "10"],
  ["ðŸ…°ï¸", "A"],
  ["ðŸ…±ï¸", "B"],
  ["ðŸ†Ž", "AB"],
  ["ðŸ†‘", "CL"],
  ["ðŸ…¾ï¸", "O"],
  ["ðŸ…¿", "P"],
  ["ðŸ†˜", "SOS"],
  ["ðŸ…²", "C"],
  ["ðŸ…³", "D"],
  ["ðŸ…´", "E"],
  ["ðŸ…µ", "F"],
  ["ðŸ…¶", "G"],
  ["ðŸ…·", "H"],
  ["ðŸ…¸", "I"],
  ["ðŸ…¹", "J"],
  ["ðŸ…º", "K"],
  ["ðŸ…»", "L"],
  ["ðŸ…¼", "M"],
  ["ðŸ…½", "N"],
  ["ðŸ†€", "Q"],
  ["ðŸ†", "R"],
  ["ðŸ†‚", "S"],
  ["ðŸ†ƒ", "T"],
  ["ðŸ†„", "U"],
  ["ðŸ†…", "V"],
  ["ðŸ††", "W"],
  ["ðŸ†‡", "X"],
  ["ðŸ†ˆ", "Y"],
  ["ðŸ†‰", "Z"]
];
var replacements_default = replacements;

// node_modules/@sindresorhus/transliterate/index.js
var doCustomReplacements = (string, replacements2) => {
  for (const [key, value] of replacements2) {
    string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
  }
  return string;
};
function transliterate(string, options) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string}\``);
  }
  options = {
    customReplacements: [],
    ...options
  };
  const customReplacements = new Map([
    ...replacements_default,
    ...options.customReplacements
  ]);
  string = string.normalize();
  string = doCustomReplacements(string, customReplacements);
  string = string.normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").normalize();
  return string;
}

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var overridableReplacements = [
  ["&", " and "],
  ["ðŸ¦„", " unicorn "],
  ["â™¥", " love "]
];
var overridable_replacements_default = overridableReplacements;

// node_modules/@sindresorhus/slugify/index.js
var decamelize = (string) => {
  return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-rt-z\d]+)/g, "$1 $2");
};
var removeMootSeparators = (string, separator) => {
  const escapedSeparator = escapeStringRegexp(separator);
  return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
};
var buildPatternSlug = (options) => {
  let negationSetPattern = "a-z\\d";
  negationSetPattern += options.lowercase ? "" : "A-Z";
  if (options.preserveCharacters.length > 0) {
    for (const character of options.preserveCharacters) {
      if (character === options.separator) {
        throw new Error(`The separator character \`${options.separator}\` cannot be included in preserved characters: ${options.preserveCharacters}`);
      }
      negationSetPattern += escapeStringRegexp(character);
    }
  }
  return new RegExp(`[^${negationSetPattern}]+`, "g");
};
function slugify(string, options) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string}\``);
  }
  options = {
    separator: "-",
    lowercase: true,
    decamelize: true,
    customReplacements: [],
    preserveLeadingUnderscore: false,
    preserveTrailingDash: false,
    preserveCharacters: [],
    ...options
  };
  const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
  const shouldAppendDash = options.preserveTrailingDash && string.endsWith("-");
  const customReplacements = new Map([
    ...overridable_replacements_default,
    ...options.customReplacements
  ]);
  string = transliterate(string, { customReplacements });
  if (options.decamelize) {
    string = decamelize(string);
  }
  const patternSlug = buildPatternSlug(options);
  if (options.lowercase) {
    string = string.toLowerCase();
  }
  string = string.replace(/([a-zA-Z\d]+)'([ts])(\s|$)/g, "$1$2$3");
  string = string.replace(patternSlug, options.separator);
  string = string.replace(/\\/g, "");
  if (options.separator) {
    string = removeMootSeparators(string, options.separator);
  }
  if (shouldPrependUnderscore) {
    string = `_${string}`;
  }
  if (shouldAppendDash) {
    string = `${string}-`;
  }
  return string;
}

// node_modules/prosemirror-schema-list/dist/index.js
function splitListItem(itemType, itemAttrs) {
  return function(state, dispatch) {
    let { $from, $to, node } = state.selection;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to))
      return false;
    let grandParent = $from.node(-1);
    if (grandParent.type != itemType)
      return false;
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1)
        return false;
      if (dispatch) {
        let wrap = Fragment.empty;
        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)
          wrap = Fragment.from($from.node(d).copy(wrap));
        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap = wrap.append(Fragment.from(itemType.createAndFill()));
        let start = $from.before($from.depth - (depthBefore - 1));
        let tr2 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
        let sel = -1;
        tr2.doc.nodesBetween(start, tr2.doc.content.size, (node2, pos) => {
          if (sel > -1)
            return false;
          if (node2.isTextblock && node2.content.size == 0)
            sel = pos + 1;
        });
        if (sel > -1)
          tr2.setSelection(Selection.near(tr2.doc.resolve(sel)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    let tr = state.tr.delete($from.pos, $to.pos);
    let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : void 0;
    if (!canSplit(tr.doc, $from.pos, 2, types))
      return false;
    if (dispatch)
      dispatch(tr.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let after = tr.mapping.map(end, -1) - 1;
  if (canJoin(tr.doc, after))
    tr.join(after);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/mdast-util-definitions/lib/index.js
function definitions(tree) {
  const cache = /* @__PURE__ */ new Map();
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit(tree, "definition", function(definition2) {
    const id = clean(definition2.identifier);
    if (id && !cache.get(id)) {
      cache.set(id, definition2);
    }
  });
  return definition;
  function definition(identifier) {
    const id = clean(identifier);
    return cache.get(id);
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}

// node_modules/remark-inline-links/lib/index.js
function remarkInlineLinks() {
  return function(tree) {
    const definition = definitions(tree);
    visit(tree, function(node, index, parent) {
      if (node.type === "definition" && parent !== void 0 && typeof index === "number") {
        parent.children.splice(index, 1);
        return [SKIP, index];
      }
      if (node.type === "imageReference" || node.type === "linkReference") {
        const def = definition(node.identifier);
        if (def && parent && typeof index === "number") {
          parent.children[index] = node.type === "imageReference" ? { type: "image", url: def.url, title: def.title, alt: node.alt } : {
            type: "link",
            url: def.url,
            title: def.title,
            children: node.children
          };
          return [SKIP, index];
        }
      }
    });
  };
}

// node_modules/@milkdown/preset-commonmark/lib/index.es.js
function at(t, e) {
  var o;
  if (!(e.childCount >= 1 && ((o = e.lastChild) == null ? void 0 : o.type.name) === "hardbreak")) {
    t.next(e.content);
    return;
  }
  const a = [];
  e.content.forEach((s, l, i) => {
    i !== e.childCount - 1 && a.push(s);
  }), t.next(Fragment.fromArray(a));
}
function n(t, e) {
  return Object.assign(t, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), t;
}
var ee = we("emphasis");
n(ee, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
var R = ye("emphasis", (t) => ({
  attrs: {
    marker: {
      default: t.get(Q).emphasis || "*"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", t.get(ee.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, r) => {
      e.withMark(r, "emphasis", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n(R.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
n(R.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
var te = re("ToggleEmphasis", (t) => () => toggleMark(R.type(t)));
n(te, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
var nt = oe((t) => markRule(/(?:^|[^*])\*([^*]+)\*$/, R.type(t), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: r }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: r + 1 }
}));
n(nt, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
var ot = oe((t) => markRule(/(?:^|[^_])_([^_]+)_$/, R.type(t), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: r }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: r + 1 }
}));
n(ot, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
var re2 = ge("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(te.key);
    }
  }
});
n(re2.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
n(re2.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
var ae = we("strong");
n(ae, {
  displayName: "Attr<strong>",
  group: "Strong"
});
var $ = ye("strong", (t) => ({
  attrs: {
    marker: {
      default: t.get(Q).strong || "*"
    }
  },
  parseDOM: [
    { tag: "b" },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" }
  ],
  toDOM: (e) => ["strong", t.get(ae.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, r) => {
      e.withMark(r, "strong", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n($.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
n($.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
var ne = re("ToggleStrong", (t) => () => toggleMark($.type(t)));
n(ne, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
var st = oe((t) => markRule(/(?:\*\*|__)([^*_]+)(?:\*\*|__)$/, $.type(t), {
  getAttr: (e) => ({
    marker: e[0].startsWith("*") ? "*" : "_"
  })
}));
n(st, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
var oe2 = ge("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(ne.key);
    }
  }
});
n(oe2.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
n(oe2.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
var se = we("inlineCode");
n(se, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
var x = ye("inlineCode", (t) => ({
  priority: 100,
  code: true,
  inclusive: false,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", t.get(se.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, r, a) => {
      e.openMark(a), e.addText(r.value), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, r, a) => {
      e.withMark(r, "inlineCode", a.text || "");
    }
  }
}));
n(x.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
n(x.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
var le = re("ToggleInlineCode", (t) => () => (e, r) => {
  const { selection: a, tr: o } = e;
  if (a.empty)
    return false;
  const { from: s, to: l } = a;
  return e.doc.rangeHasMark(s, l, x.type(t)) ? (r == null || r(o.removeMark(s, l, x.type(t))), true) : (Object.keys(e.schema.marks).filter((m) => m !== x.type.name).map((m) => e.schema.marks[m]).forEach((m) => {
    o.removeMark(s, l, m);
  }), r == null || r(o.addMark(s, l, x.type(t).create())), true);
});
n(le, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
var lt = oe((t) => markRule(/(?:\`)([^\`]+)(?:\`)$/, x.type(t)));
n(lt, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
var ie = ge("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(le.key);
    }
  }
});
n(ie.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
n(ie.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
var de = we("link");
n(de, {
  displayName: "Attr<link>",
  group: "Link"
});
var B = ye("link", (t) => ({
  attrs: {
    href: {},
    title: { default: null }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { href: e.getAttribute("href"), title: e.getAttribute("title") };
      }
    }
  ],
  toDOM: (e) => ["a", { ...t.get(de.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, r, a) => {
      const o = r.url, s = r.title;
      e.openMark(a, { href: o, title: s }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, r) => {
      e.withMark(r, "link", void 0, {
        title: r.attrs.title,
        url: r.attrs.href
      });
    }
  }
}));
n(B.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
var it = re("ToggleLink", (t) => (e = {}) => toggleMark(B.type(t), e));
n(it, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
var dt = re("UpdateLink", (t) => (e = {}) => (r, a) => {
  if (!a)
    return false;
  let o, s = -1;
  const { selection: l } = r, { from: i, to: d } = l;
  if (r.doc.nodesBetween(i, i === d ? d + 1 : d, (k, b) => {
    if (B.type(t).isInSet(k.marks))
      return o = k, s = b, false;
  }), !o)
    return false;
  const m = o.marks.find(({ type: k }) => k === B.type(t));
  if (!m)
    return false;
  const p = s, y = s + o.nodeSize, { tr: g } = r, C = B.type(t).create({ ...m.attrs, ...e });
  return C ? (a(
    g.removeMark(p, y, m).addMark(p, y, C).setSelection(new TextSelection(g.selection.$anchor)).scrollIntoView()
  ), true) : false;
});
n(dt, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
var mt = W("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: t }) => t === "root",
    runner: (t, e, r) => {
      t.injectRoot(e, r);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "doc",
    runner: (t, e) => {
      t.openNode("root"), t.next(e.content);
    }
  }
}));
n(mt, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
var me = he("paragraph");
n(me, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
var w = fe("paragraph", (t) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", t.get(me.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, r, a) => {
      e.openNode(a), r.children ? e.next(r.children) : e.addText(r.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, r) => {
      e.openNode("paragraph"), at(e, r), e.closeNode();
    }
  }
}));
n(w.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
n(w.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
var pe = re("TurnIntoText", (t) => () => setBlockType(w.type(t)));
n(pe, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
var ce = ge("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(pe.key);
    }
  }
});
n(ce.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
n(ce.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
var Dt = Array(6).fill(0).map((t, e) => e + 1);
function _t(t) {
  return slugify(t.textContent);
}
var z = h(_t, "headingIdGenerator");
n(z, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
var ue2 = he("heading");
n(ue2, {
  displayName: "Attr<heading>",
  group: "Heading"
});
var H = fe("heading", (t) => {
  const e = t.get(z.key);
  return {
    content: "inline*",
    group: "block",
    defining: true,
    attrs: {
      id: {
        default: ""
      },
      level: {
        default: 1
      }
    },
    parseDOM: Dt.map((r) => ({
      tag: `h${r}`,
      getAttrs: (a) => {
        if (!(a instanceof HTMLElement))
          throw S(a);
        return { level: r, id: a.id };
      }
    })),
    toDOM: (r) => [
      `h${r.attrs.level}`,
      {
        ...t.get(ue2.key)(r),
        id: r.attrs.id || e(r)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: r }) => r === "heading",
      runner: (r, a, o) => {
        const s = a.depth;
        r.openNode(o, { level: s }), r.next(a.children), r.closeNode();
      }
    },
    toMarkdown: {
      match: (r) => r.type.name === "heading",
      runner: (r, a) => {
        r.openNode("heading", void 0, { depth: a.attrs.level }), at(r, a), r.closeNode();
      }
    }
  };
});
n(H.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
n(H.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
var pt = oe((t) => textblockTypeInputRule(/^(?<hashes>#+)\s$/, H.type(t), (e) => {
  var l, i;
  const r = ((i = (l = e.groups) == null ? void 0 : l.hashes) == null ? void 0 : i.length) || 0, a = t.get(L), { $from: o } = a.state.selection, s = o.node();
  if (s.type.name === "heading") {
    let d = Number(s.attrs.level) + Number(r);
    return d > 6 && (d = 6), { level: d };
  }
  return { level: r };
}));
n(pt, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
var L2 = re("WrapInHeading", (t) => (e) => (e ?? (e = 1), e < 1 ? setBlockType(w.type(t)) : setBlockType(H.type(t), { level: e })));
n(L2, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
var ge2 = re("DowngradeHeading", (t) => () => (e, r, a) => {
  const { $from: o } = e.selection, s = o.node();
  if (s.type !== H.type(t) || !e.selection.empty || o.parentOffset !== 0)
    return false;
  const l = s.attrs.level - 1;
  return l ? (r == null || r(
    e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
      ...s.attrs,
      level: l
    })
  ), true) : setBlockType(w.type(t))(e, r, a);
});
n(ge2, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
var ke2 = ge("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(ge2.key);
    }
  }
});
n(ke2.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
n(ke2.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
var ye2 = he("blockquote");
n(ye2, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
var q = fe("blockquote", (t) => ({
  content: "block+",
  group: "block",
  defining: true,
  parseDOM: [{ tag: "blockquote" }],
  toDOM: (e) => ["blockquote", t.get(ye2.key)(e), 0],
  parseMarkdown: {
    match: ({ type: e }) => e === "blockquote",
    runner: (e, r, a) => {
      e.openNode(a).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "blockquote",
    runner: (e, r) => {
      e.openNode("blockquote").next(r.content).closeNode();
    }
  }
}));
n(q.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
n(q.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
var ct = oe((t) => wrappingInputRule(/^\s*>\s$/, q.type(t)));
n(ct, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
var he2 = re("WrapInBlockquote", (t) => () => wrapIn(q.type(t)));
n(he2, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
var fe2 = ge("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(he2.key);
    }
  }
});
n(fe2.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
n(fe2.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
var Ne = he("codeBlock", () => ({
  pre: {},
  code: {}
}));
n(Ne, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
var W2 = fe("code_block", (t) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: true,
  code: true,
  attrs: {
    language: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const r = t.get(Ne.key)(e);
    return [
      "pre",
      {
        ...r.pre,
        "data-language": e.attrs.language
      },
      ["code", r.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, r, a) => {
      const o = r.lang, s = r.value;
      e.openNode(a, { language: o }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, r) => {
      var a;
      e.addNode("code", void 0, ((a = r.content.firstChild) == null ? void 0 : a.text) || "", {
        lang: r.attrs.language
      });
    }
  }
}));
n(W2.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
n(W2.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
var ut = oe((t) => textblockTypeInputRule(/^```(?<language>[a-z]*)?[\s\n]$/, W2.type(t), (e) => {
  var r;
  return {
    language: ((r = e.groups) == null ? void 0 : r.language) ?? ""
  };
}));
n(ut, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
var Ie = re("CreateCodeBlock", (t) => (e = "") => setBlockType(W2.type(t), { language: e }));
n(Ie, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
var Et = re("UpdateCodeBlockLanguage", () => ({ pos: t, language: e } = { pos: -1, language: "" }) => (r, a) => t >= 0 ? (a == null || a(r.tr.setNodeAttribute(t, "language", e)), true) : false);
n(Et, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
var Ce = ge("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ie.key);
    }
  }
});
n(Ce.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
n(Ce.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
var Me = he("image");
n(Me, {
  displayName: "Attr<image>",
  group: "Image"
});
var v = fe("image", (t) => ({
  inline: true,
  group: "inline",
  selectable: true,
  draggable: true,
  marks: "",
  atom: true,
  defining: true,
  isolating: true,
  attrs: {
    src: { default: "" },
    alt: { default: "" },
    title: { default: "" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...t.get(Me.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, r, a) => {
      const o = r.url, s = r.alt, l = r.title;
      e.addNode(a, {
        src: o,
        alt: s,
        title: l
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, r) => {
      e.addNode("image", void 0, void 0, {
        title: r.attrs.title,
        url: r.attrs.src,
        alt: r.attrs.alt
      });
    }
  }
}));
n(v.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
n(v.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
var gt = re("InsertImage", (t) => (e = {}) => (r, a) => {
  if (!a)
    return true;
  const { src: o = "", alt: s = "", title: l = "" } = e, i = v.type(t).create({ src: o, alt: s, title: l });
  return i && a(r.tr.replaceSelectionWith(i).scrollIntoView()), true;
});
n(gt, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
var kt = re("UpdateImage", (t) => (e = {}) => (r, a) => {
  const o = findSelectedNodeOfType(r.selection, v.type(t));
  if (!o)
    return false;
  const { node: s, pos: l } = o, i = { ...s.attrs }, { src: d, alt: m, title: p } = e;
  return d !== void 0 && (i.src = d), m !== void 0 && (i.alt = m), p !== void 0 && (i.title = p), a == null || a(r.tr.setNodeMarkup(l, void 0, i).scrollIntoView()), true;
});
n(kt, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
var Pt = oe((t) => new InputRule(
  /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
  (e, r, a, o) => {
    const [s, l, i = "", d] = r;
    return s ? e.tr.replaceWith(a, o, v.type(t).create({ src: i, alt: l, title: d })) : null;
  }
));
n(Pt, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
var V = he("hardbreak", (t) => ({
  "data-type": "hardbreak",
  "data-is-inline": t.attrs.isInline
}));
n(V, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
var S2 = fe("hardbreak", (t) => ({
  inline: true,
  group: "inline",
  attrs: {
    isInline: {
      default: false
    }
  },
  selectable: false,
  parseDOM: [{ tag: "br" }, { tag: 'span[data-type="hardbreak"]', getAttrs: () => ({ isInline: true }) }],
  toDOM: (e) => e.attrs.isInline ? ["span", t.get(V.key)(e), " "] : ["br", t.get(V.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, r, a) => {
      var o;
      e.addNode(a, { isInline: !!((o = r.data) != null && o.isInline) });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, r) => {
      r.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
n(S2.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
n(S2.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
var be = re("InsertHardbreak", (t) => () => (e, r) => {
  var s;
  const { selection: a, tr: o } = e;
  if (!(a instanceof TextSelection))
    return false;
  if (a.empty) {
    const l = a.$from.node();
    if (l.childCount > 0 && ((s = l.lastChild) == null ? void 0 : s.type.name) === "hardbreak")
      return r == null || r(
        o.replaceRangeWith(a.to - 1, a.to, e.schema.node("paragraph")).setSelection(Selection.near(o.doc.resolve(a.to))).scrollIntoView()
      ), true;
  }
  return r == null || r(o.setMeta("hardbreak", true).replaceSelectionWith(S2.type(t).create()).scrollIntoView()), true;
});
n(be, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
var Le = ge("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(be.key);
    }
  }
});
n(Le.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
n(Le.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
var xe = he("hr");
n(xe, {
  displayName: "Attr<hr>",
  group: "Hr"
});
var F = fe("hr", (t) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", t.get(xe.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, r, a) => {
      e.addNode(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
n(F.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
n(F.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
var yt = oe((t) => new InputRule(
  /^(?:---|___\s|\*\*\*\s)$/,
  (e, r, a, o) => {
    const { tr: s } = e;
    return r[0] && s.replaceWith(a - 1, o, F.type(t).create()), s;
  }
));
n(yt, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
var ht = re("InsertHr", (t) => () => (e, r) => {
  if (!r)
    return true;
  const a = w.node.type(t).create(), { tr: o, selection: s } = e, { from: l } = s, i = F.type(t).create();
  if (!i)
    return true;
  const d = o.replaceSelectionWith(i).insert(l, a), m = Selection.findFrom(d.doc.resolve(l), 1, true);
  return m && r(d.setSelection(m).scrollIntoView()), true;
});
n(ht, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
var Se = he("bulletList");
n(Se, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
var O = fe("bullet_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: false
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...t.get(Se.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "false";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: false, spread: r.attrs.spread === "true" }).next(r.content).closeNode();
    }
  }
}));
n(O.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
n(O.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
var ft = oe((t) => wrappingInputRule(/^\s*([-+*])\s$/, O.type(t)));
n(ft, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
var Ae = re("WrapInBulletList", (t) => () => wrapIn(O.type(t)));
n(Ae, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
var we2 = ge("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ae.key);
    }
  }
});
n(we2.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
n(we2.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
var He = he("orderedList");
n(He, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
var T = fe("ordered_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1
    },
    spread: {
      default: false
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...t.get(He.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !!r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: true, start: 1, spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(T.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
n(T.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
var Nt = oe((t) => wrappingInputRule(
  /^\s*(\d+)\.\s$/,
  T.type(t),
  (e) => ({ order: Number(e[1]) }),
  (e, r) => r.childCount + r.attrs.order === Number(e[1])
));
n(Nt, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
var Be = re("WrapInOrderedList", (t) => () => wrapIn(T.type(t)));
n(Be, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
var Re = ge("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Be.key);
    }
  }
});
n(Re.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
n(Re.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
var ve = he("listItem");
n(ve, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
var M = fe("list_item", (t) => ({
  group: "listItem",
  content: "(paragraph|blockquote) block*",
  attrs: {
    label: {
      default: "â€¢"
    },
    listType: {
      default: "bullet"
    },
    spread: {
      default: "true"
    }
  },
  defining: true,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...t.get(ve.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, r, a) => {
      const o = r.label != null ? `${r.label}.` : "â€¢", s = r.label != null ? "ordered" : "bullet", l = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { label: o, listType: s, spread: l }), e.next(r.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, r) => {
      e.openNode("listItem", void 0, { spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(M.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
n(M.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
var Oe = re("SinkListItem", (t) => () => sinkListItem(M.type(t)));
n(Oe, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
var Te = re("LiftListItem", (t) => () => liftListItem(M.type(t)));
n(Te, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
var Ke = re("SplitListItem", (t) => () => splitListItem(M.type(t)));
n(Ke, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function $t(t) {
  return (e, r, a) => {
    const { selection: o } = e;
    if (!(o instanceof TextSelection))
      return false;
    const { empty: s, $from: l } = o;
    if (!s || l.parentOffset !== 0)
      return false;
    const i = l.node(-1);
    return i.type !== M.type(t) || i.firstChild !== l.node() || l.node(-2).childCount > 1 ? false : liftListItem(M.type(t))(e, r, a);
  };
}
var De = re("LiftFirstListItem", (t) => () => $t(t));
n(De, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
var _e = ge("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ke.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Oe.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Te.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(De.key);
    }
  }
});
n(_e.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
n(_e.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
var It = W("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: t }) => t === "text",
    runner: (t, e) => {
      t.addText(e.value);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "text",
    runner: (t, e) => {
      t.addNode("text", void 0, e.text);
    }
  }
}));
n(It, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
var Ee = he("html");
n(Ee, {
  displayName: "Attr<html>",
  group: "Html"
});
var Pe = fe("html", (t) => ({
  atom: true,
  group: "inline",
  inline: true,
  attrs: {
    value: {
      default: ""
    }
  },
  toDOM: (e) => {
    const r = document.createElement("span"), a = {
      ...t.get(Ee.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return r.textContent = e.attrs.value, ["span", a, e.attrs.value];
  },
  parseDOM: [{
    tag: 'span[data-type="html"]',
    getAttrs: (e) => ({
      value: e.dataset.value ?? ""
    })
  }],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, r, a) => {
      e.addNode(a, { value: r.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, r) => {
      e.addNode("html", void 0, r.attrs.value);
    }
  }
}));
n(Pe.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
n(Pe.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
var qt = [
  mt,
  me,
  w,
  z,
  ue2,
  H,
  V,
  S2,
  ye2,
  q,
  Ne,
  W2,
  xe,
  F,
  Me,
  v,
  Se,
  O,
  He,
  T,
  ve,
  M,
  ee,
  R,
  ae,
  $,
  se,
  x,
  de,
  B,
  Ee,
  Pe,
  It
].flat();
var Wt = [
  ct,
  ft,
  Nt,
  ut,
  yt,
  pt
].flat();
var Ft = [
  nt,
  ot,
  lt,
  st
];
var Vt = [
  pe,
  he2,
  L2,
  ge2,
  Ie,
  be,
  ht,
  gt,
  kt,
  Be,
  Ae,
  Oe,
  Ke,
  Te,
  De,
  te,
  le,
  ne,
  it,
  dt
];
var Ut = [
  fe2,
  Ce,
  Le,
  ke2,
  _e,
  Re,
  we2,
  ce,
  re2,
  ie,
  oe2
].flat();
var $e = ke("remarkAddOrderInList", () => () => (t) => {
  visit(t, "list", (e) => {
    if (e.ordered) {
      const r = e.start ?? 1;
      e.children.forEach((a, o) => {
        a.label = o + r;
      });
    }
  });
});
n($e.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
n($e.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
var qe = ke("remarkLineBreak", () => () => (t) => {
  const e = /[\t ]*(?:\r?\n|\r)/g;
  visit(t, "text", (r, a, o) => {
    if (!r.value || typeof r.value != "string")
      return;
    const s = [];
    let l = 0;
    e.lastIndex = 0;
    let i = e.exec(r.value);
    for (; i; ) {
      const m = i.index;
      l !== m && s.push({ type: "text", value: r.value.slice(l, m) }), s.push({ type: "break", data: { isInline: true } }), l = m + i[0].length, i = e.exec(r.value);
    }
    if (s.length > 0 && o && typeof a == "number")
      return l < r.value.length && s.push({ type: "text", value: r.value.slice(l) }), o.children.splice(a, 1, ...s), a + s.length;
  });
});
n(qe.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
n(qe.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
var We = ke("remarkInlineLink", () => remarkInlineLinks);
n(We.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
n(We.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
var Gt = (t) => !!t.children;
var jt = (t) => t.type === "html";
function zt(t, e) {
  return r(t, 0, null)[0];
  function r(a, o, s) {
    if (Gt(a)) {
      const l = [];
      for (let i = 0, d = a.children.length; i < d; i++) {
        const m = a.children[i];
        if (m) {
          const p = r(m, i, a);
          if (p)
            for (let y = 0, g = p.length; y < g; y++) {
              const C = p[y];
              C && l.push(C);
            }
        }
      }
      a.children = l;
    }
    return e(a, o, s);
  }
}
var Fe = ke("remarkHTMLTransformer", () => () => (t) => {
  zt(t, (e, r, a) => jt(e) ? ((a == null ? void 0 : a.type) === "root" && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
});
n(Fe.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
n(Fe.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
var Ve = ke("remarkMarker", () => () => (t, e) => {
  const r = (a) => e.value.charAt(a.position.start.offset);
  visit(t, (a) => ["strong", "emphasis"].includes(a.type), (a) => {
    a.marker = r(a);
  });
});
n(Ve.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
n(Ve.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
var Ct = ue(() => {
  let t = false;
  const e = new PluginKey("MILKDOWN_INLINE_NODES_CURSOR"), r = new Plugin({
    key: e,
    state: {
      init() {
        return false;
      },
      apply(a) {
        if (!a.selection.empty)
          return false;
        const o = a.selection.$from, s = o.nodeBefore, l = o.nodeAfter;
        return !!(s && l && s.isInline && !s.isText && l.isInline && !l.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (a, o) => t ? (t = false, requestAnimationFrame(() => {
          if (r.getState(a.state)) {
            const l = a.state.selection.from;
            o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", l));
          }
        }), true) : false,
        compositionstart: (a) => (r.getState(a.state) && (t = true), false),
        beforeinput: (a, o) => {
          if (r.getState(a.state) && o instanceof InputEvent && o.data && !t) {
            const l = a.state.selection.from;
            return o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", l)), true;
          }
          return false;
        }
      },
      decorations(a) {
        if (r.getState(a)) {
          const l = a.selection.$from.pos, i = document.createElement("span"), d = Decoration.widget(l, i, {
            side: -1
          }), m = document.createElement("span"), p = Decoration.widget(l, m);
          return setTimeout(() => {
            i.contentEditable = "true", m.contentEditable = "true";
          }), DecorationSet.create(a.doc, [d, p]);
        }
        return DecorationSet.empty;
      }
    }
  });
  return r;
});
n(Ct, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
var Mt = ue((t) => new Plugin({
  key: new PluginKey("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, r, a) => {
    if (!e.length)
      return;
    const [o] = e;
    if (!o)
      return;
    const [s] = o.steps;
    if (o.getMeta("hardbreak")) {
      if (!(s instanceof ReplaceStep))
        return;
      const { from: d } = s;
      return a.tr.setNodeMarkup(d, S2.type(t), void 0, []);
    }
    if (s instanceof AddMarkStep) {
      let d = a.tr;
      const { from: m, to: p } = s;
      return a.doc.nodesBetween(m, p, (y, g) => {
        y.type === S2.type(t) && (d = d.setNodeMarkup(g, S2.type(t), void 0, []));
      }), d;
    }
  }
}));
n(Mt, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
var Ue = h(["table", "code_block"], "hardbreakFilterNodes");
n(Ue, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
var bt = ue((t) => {
  const e = t.get(Ue.key);
  return new Plugin({
    key: new PluginKey("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (r, a) => {
      const o = r.getMeta("hardbreak"), [s] = r.steps;
      if (o && s) {
        const { from: l } = s, i = a.doc.resolve(l);
        let d = i.depth, m = true;
        for (; d > 0; )
          e.includes(i.node(d).type.name) && (m = false), d--;
        return m;
      }
      return true;
    }
  });
});
n(bt, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
var Lt = ue((t) => {
  const e = new PluginKey("MILKDOWN_HEADING_ID"), r = (a) => {
    if (a.composing)
      return;
    const o = t.get(z.key), s = a.state.tr.setMeta("addToHistory", false);
    let l = false;
    a.state.doc.descendants((i, d) => {
      if (i.type === H.type(t)) {
        if (i.textContent.trim().length === 0)
          return;
        const m = i.attrs, p = o(i);
        m.id !== p && (l = true, s.setMeta(e, true).setNodeMarkup(d, void 0, {
          ...m,
          id: p
        }));
      }
    }), l && a.dispatch(s);
  };
  return new Plugin({
    key: e,
    view: (a) => (r(a), {
      update: (o, s) => {
        o.state.doc.eq(s.doc) || r(o);
      }
    })
  });
});
n(Lt, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
var xt = ue((t) => {
  const e = (r) => {
    if (r.composing || !r.editable)
      return;
    const a = T.type(t), o = O.type(t), s = M.type(t), l = r.state, i = (p, y) => {
      let g = false;
      const C = `${y + 1}.`;
      return p.label !== C && (p.label = C, g = true), g;
    };
    let d = l.tr, m = false;
    l.doc.descendants((p, y, g, C) => {
      if (p.type === o) {
        const k = p.maybeChild(0);
        (k == null ? void 0 : k.type) === s && k.attrs.listType === "ordered" && (m = true, d.setNodeMarkup(y, a, { spread: "true" }), p.descendants((b, Ge, Qt, St) => {
          if (b.type === s) {
            const je2 = { ...b.attrs };
            i(je2, St) && (d = d.setNodeMarkup(Ge, void 0, je2));
          }
          return false;
        }));
      } else if (p.type === s && (g == null ? void 0 : g.type) === a) {
        const k = { ...p.attrs };
        let b = false;
        k.listType !== "ordered" && (k.listType = "ordered", b = true), (g == null ? void 0 : g.maybeChild(0)) && (b = i(k, C)), b && (d = d.setNodeMarkup(y, void 0, k), m = true);
      }
    }), m && r.dispatch(d.setMeta("addToHistory", false));
  };
  return new Plugin({
    key: new PluginKey("MILKDOWN_KEEP_LIST_ORDER"),
    view: (r) => (e(r), {
      update: (a) => {
        e(a);
      }
    })
  });
});
n(xt, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
var Jt = [
  Mt,
  Ue,
  bt,
  Ct,
  $e,
  We,
  qe,
  Fe,
  Ve,
  Lt,
  xt
].flat();
var cr = [qt, Wt, Ft, Vt, Ut, Jt].flat();

export {
  escapeStringRegexp,
  R,
  te,
  $,
  ne,
  x,
  le,
  B,
  w,
  H,
  q,
  W2 as W,
  v,
  F,
  O,
  T,
  M,
  cr
};
//# sourceMappingURL=chunk-AMUWVZB5.js.map
