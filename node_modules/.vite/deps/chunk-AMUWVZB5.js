import {
  AddMarkStep,
  Decoration,
  DecorationSet,
  Fragment,
  InputRule,
  L,
  NodeRange,
  Plugin,
  PluginKey,
  Q,
  ReplaceAroundStep,
  ReplaceStep,
  S,
  SKIP,
  Selection,
  Slice,
  TextSelection,
  W,
  canJoin,
  canSplit,
  fe,
  findSelectedNodeOfType,
  ge,
  h,
  he,
  je,
  ke,
  liftTarget,
  markRule,
  oe,
  re2 as re,
  setBlockType,
  textblockTypeInputRule,
  toggleMark,
  ue,
  visit,
  we,
  wrapIn,
  wrappingInputRule,
  ye
} from "./chunk-GFK4PW34.js";

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/@sindresorhus/transliterate/replacements.js
var replacements = [
  // German umlauts
  ["ß", "ss"],
  ["ẞ", "Ss"],
  ["ä", "ae"],
  ["Ä", "Ae"],
  ["ö", "oe"],
  ["Ö", "Oe"],
  ["ü", "ue"],
  ["Ü", "Ue"],
  // Latin
  ["À", "A"],
  ["Á", "A"],
  ["Â", "A"],
  ["Ã", "A"],
  ["Ä", "Ae"],
  ["Å", "A"],
  ["Æ", "AE"],
  ["Ç", "C"],
  ["È", "E"],
  ["É", "E"],
  ["Ê", "E"],
  ["Ë", "E"],
  ["Ì", "I"],
  ["Í", "I"],
  ["Î", "I"],
  ["Ï", "I"],
  ["Ð", "D"],
  ["Ñ", "N"],
  ["Ò", "O"],
  ["Ó", "O"],
  ["Ô", "O"],
  ["Õ", "O"],
  ["Ö", "Oe"],
  ["Ő", "O"],
  ["Ø", "O"],
  ["Ù", "U"],
  ["Ú", "U"],
  ["Û", "U"],
  ["Ü", "Ue"],
  ["Ű", "U"],
  ["Ý", "Y"],
  ["Þ", "TH"],
  ["ß", "ss"],
  ["à", "a"],
  ["á", "a"],
  ["â", "a"],
  ["ã", "a"],
  ["ä", "ae"],
  ["å", "a"],
  ["æ", "ae"],
  ["ç", "c"],
  ["è", "e"],
  ["é", "e"],
  ["ê", "e"],
  ["ë", "e"],
  ["ì", "i"],
  ["í", "i"],
  ["î", "i"],
  ["ï", "i"],
  ["ð", "d"],
  ["ñ", "n"],
  ["ò", "o"],
  ["ó", "o"],
  ["ô", "o"],
  ["õ", "o"],
  ["ö", "oe"],
  ["ő", "o"],
  ["ø", "o"],
  ["ù", "u"],
  ["ú", "u"],
  ["û", "u"],
  ["ü", "ue"],
  ["ű", "u"],
  ["ý", "y"],
  ["þ", "th"],
  ["ÿ", "y"],
  ["ẞ", "SS"],
  // Vietnamese
  ["à", "a"],
  ["À", "A"],
  ["á", "a"],
  ["Á", "A"],
  ["â", "a"],
  ["Â", "A"],
  ["ã", "a"],
  ["Ã", "A"],
  ["è", "e"],
  ["È", "E"],
  ["é", "e"],
  ["É", "E"],
  ["ê", "e"],
  ["Ê", "E"],
  ["ì", "i"],
  ["Ì", "I"],
  ["í", "i"],
  ["Í", "I"],
  ["ò", "o"],
  ["Ò", "O"],
  ["ó", "o"],
  ["Ó", "O"],
  ["ô", "o"],
  ["Ô", "O"],
  ["õ", "o"],
  ["Õ", "O"],
  ["ù", "u"],
  ["Ù", "U"],
  ["ú", "u"],
  ["Ú", "U"],
  ["ý", "y"],
  ["Ý", "Y"],
  ["ă", "a"],
  ["Ă", "A"],
  ["Đ", "D"],
  ["đ", "d"],
  ["ĩ", "i"],
  ["Ĩ", "I"],
  ["ũ", "u"],
  ["Ũ", "U"],
  ["ơ", "o"],
  ["Ơ", "O"],
  ["ư", "u"],
  ["Ư", "U"],
  ["ạ", "a"],
  ["Ạ", "A"],
  ["ả", "a"],
  ["Ả", "A"],
  ["ấ", "a"],
  ["Ấ", "A"],
  ["ầ", "a"],
  ["Ầ", "A"],
  ["ẩ", "a"],
  ["Ẩ", "A"],
  ["ẫ", "a"],
  ["Ẫ", "A"],
  ["ậ", "a"],
  ["Ậ", "A"],
  ["ắ", "a"],
  ["Ắ", "A"],
  ["ằ", "a"],
  ["Ằ", "A"],
  ["ẳ", "a"],
  ["Ẳ", "A"],
  ["ẵ", "a"],
  ["Ẵ", "A"],
  ["ặ", "a"],
  ["Ặ", "A"],
  ["ẹ", "e"],
  ["Ẹ", "E"],
  ["ẻ", "e"],
  ["Ẻ", "E"],
  ["ẽ", "e"],
  ["Ẽ", "E"],
  ["ế", "e"],
  ["Ế", "E"],
  ["ề", "e"],
  ["Ề", "E"],
  ["ể", "e"],
  ["Ể", "E"],
  ["ễ", "e"],
  ["Ễ", "E"],
  ["ệ", "e"],
  ["Ệ", "E"],
  ["ỉ", "i"],
  ["Ỉ", "I"],
  ["ị", "i"],
  ["Ị", "I"],
  ["ọ", "o"],
  ["Ọ", "O"],
  ["ỏ", "o"],
  ["Ỏ", "O"],
  ["ố", "o"],
  ["Ố", "O"],
  ["ồ", "o"],
  ["Ồ", "O"],
  ["ổ", "o"],
  ["Ổ", "O"],
  ["ỗ", "o"],
  ["Ỗ", "O"],
  ["ộ", "o"],
  ["Ộ", "O"],
  ["ớ", "o"],
  ["Ớ", "O"],
  ["ờ", "o"],
  ["Ờ", "O"],
  ["ở", "o"],
  ["Ở", "O"],
  ["ỡ", "o"],
  ["Ỡ", "O"],
  ["ợ", "o"],
  ["Ợ", "O"],
  ["ụ", "u"],
  ["Ụ", "U"],
  ["ủ", "u"],
  ["Ủ", "U"],
  ["ứ", "u"],
  ["Ứ", "U"],
  ["ừ", "u"],
  ["Ừ", "U"],
  ["ử", "u"],
  ["Ử", "U"],
  ["ữ", "u"],
  ["Ữ", "U"],
  ["ự", "u"],
  ["Ự", "U"],
  ["ỳ", "y"],
  ["Ỳ", "Y"],
  ["ỵ", "y"],
  ["Ỵ", "Y"],
  ["ỷ", "y"],
  ["Ỷ", "Y"],
  ["ỹ", "y"],
  ["Ỹ", "Y"],
  // Arabic
  ["ء", "e"],
  ["آ", "a"],
  ["أ", "a"],
  ["ؤ", "w"],
  ["إ", "i"],
  ["ئ", "y"],
  ["ا", "a"],
  ["ب", "b"],
  ["ة", "t"],
  ["ت", "t"],
  ["ث", "th"],
  ["ج", "j"],
  ["ح", "h"],
  ["خ", "kh"],
  ["د", "d"],
  ["ذ", "dh"],
  ["ر", "r"],
  ["ز", "z"],
  ["س", "s"],
  ["ش", "sh"],
  ["ص", "s"],
  ["ض", "d"],
  ["ط", "t"],
  ["ظ", "z"],
  ["ع", "e"],
  ["غ", "gh"],
  ["ـ", "_"],
  ["ف", "f"],
  ["ق", "q"],
  ["ك", "k"],
  ["ل", "l"],
  ["م", "m"],
  ["ن", "n"],
  ["ه", "h"],
  ["و", "w"],
  ["ى", "a"],
  ["ي", "y"],
  ["َ‎", "a"],
  ["ُ", "u"],
  ["ِ‎", "i"],
  ["٠", "0"],
  ["١", "1"],
  ["٢", "2"],
  ["٣", "3"],
  ["٤", "4"],
  ["٥", "5"],
  ["٦", "6"],
  ["٧", "7"],
  ["٨", "8"],
  ["٩", "9"],
  // Persian / Farsi
  ["چ", "ch"],
  ["ک", "k"],
  ["گ", "g"],
  ["پ", "p"],
  ["ژ", "zh"],
  ["ی", "y"],
  ["۰", "0"],
  ["۱", "1"],
  ["۲", "2"],
  ["۳", "3"],
  ["۴", "4"],
  ["۵", "5"],
  ["۶", "6"],
  ["۷", "7"],
  ["۸", "8"],
  ["۹", "9"],
  // Pashto
  ["ټ", "p"],
  ["ځ", "z"],
  ["څ", "c"],
  ["ډ", "d"],
  ["ﺫ", "d"],
  ["ﺭ", "r"],
  ["ړ", "r"],
  ["ﺯ", "z"],
  ["ږ", "g"],
  ["ښ", "x"],
  ["ګ", "g"],
  ["ڼ", "n"],
  ["ۀ", "e"],
  ["ې", "e"],
  ["ۍ", "ai"],
  // Urdu
  ["ٹ", "t"],
  ["ڈ", "d"],
  ["ڑ", "r"],
  ["ں", "n"],
  ["ہ", "h"],
  ["ھ", "h"],
  ["ے", "e"],
  // Russian
  ["А", "A"],
  ["а", "a"],
  ["Б", "B"],
  ["б", "b"],
  ["В", "V"],
  ["в", "v"],
  ["Г", "G"],
  ["г", "g"],
  ["Д", "D"],
  ["д", "d"],
  ["ъе", "ye"],
  ["Ъе", "Ye"],
  ["ъЕ", "yE"],
  ["ЪЕ", "YE"],
  ["Е", "E"],
  ["е", "e"],
  ["Ё", "Yo"],
  ["ё", "yo"],
  ["Ж", "Zh"],
  ["ж", "zh"],
  ["З", "Z"],
  ["з", "z"],
  ["И", "I"],
  ["и", "i"],
  ["ый", "iy"],
  ["Ый", "Iy"],
  ["ЫЙ", "IY"],
  ["ыЙ", "iY"],
  ["Й", "Y"],
  ["й", "y"],
  ["К", "K"],
  ["к", "k"],
  ["Л", "L"],
  ["л", "l"],
  ["М", "M"],
  ["м", "m"],
  ["Н", "N"],
  ["н", "n"],
  ["О", "O"],
  ["о", "o"],
  ["П", "P"],
  ["п", "p"],
  ["Р", "R"],
  ["р", "r"],
  ["С", "S"],
  ["с", "s"],
  ["Т", "T"],
  ["т", "t"],
  ["У", "U"],
  ["у", "u"],
  ["Ф", "F"],
  ["ф", "f"],
  ["Х", "Kh"],
  ["х", "kh"],
  ["Ц", "Ts"],
  ["ц", "ts"],
  ["Ч", "Ch"],
  ["ч", "ch"],
  ["Ш", "Sh"],
  ["ш", "sh"],
  ["Щ", "Sch"],
  ["щ", "sch"],
  ["Ъ", ""],
  ["ъ", ""],
  ["Ы", "Y"],
  ["ы", "y"],
  ["Ь", ""],
  ["ь", ""],
  ["Э", "E"],
  ["э", "e"],
  ["Ю", "Yu"],
  ["ю", "yu"],
  ["Я", "Ya"],
  ["я", "ya"],
  // Romanian
  ["ă", "a"],
  ["Ă", "A"],
  ["ș", "s"],
  ["Ș", "S"],
  ["ț", "t"],
  ["Ț", "T"],
  ["ţ", "t"],
  ["Ţ", "T"],
  // Turkish
  ["ş", "s"],
  ["Ş", "S"],
  ["ç", "c"],
  ["Ç", "C"],
  ["ğ", "g"],
  ["Ğ", "G"],
  ["ı", "i"],
  ["İ", "I"],
  // Armenian
  ["ա", "a"],
  ["Ա", "A"],
  ["բ", "b"],
  ["Բ", "B"],
  ["գ", "g"],
  ["Գ", "G"],
  ["դ", "d"],
  ["Դ", "D"],
  ["ե", "ye"],
  ["Ե", "Ye"],
  ["զ", "z"],
  ["Զ", "Z"],
  ["է", "e"],
  ["Է", "E"],
  ["ը", "y"],
  ["Ը", "Y"],
  ["թ", "t"],
  ["Թ", "T"],
  ["ժ", "zh"],
  ["Ժ", "Zh"],
  ["ի", "i"],
  ["Ի", "I"],
  ["լ", "l"],
  ["Լ", "L"],
  ["խ", "kh"],
  ["Խ", "Kh"],
  ["ծ", "ts"],
  ["Ծ", "Ts"],
  ["կ", "k"],
  ["Կ", "K"],
  ["հ", "h"],
  ["Հ", "H"],
  ["ձ", "dz"],
  ["Ձ", "Dz"],
  ["ղ", "gh"],
  ["Ղ", "Gh"],
  ["ճ", "tch"],
  ["Ճ", "Tch"],
  ["մ", "m"],
  ["Մ", "M"],
  ["յ", "y"],
  ["Յ", "Y"],
  ["ն", "n"],
  ["Ն", "N"],
  ["շ", "sh"],
  ["Շ", "Sh"],
  ["ո", "vo"],
  ["Ո", "Vo"],
  ["չ", "ch"],
  ["Չ", "Ch"],
  ["պ", "p"],
  ["Պ", "P"],
  ["ջ", "j"],
  ["Ջ", "J"],
  ["ռ", "r"],
  ["Ռ", "R"],
  ["ս", "s"],
  ["Ս", "S"],
  ["վ", "v"],
  ["Վ", "V"],
  ["տ", "t"],
  ["Տ", "T"],
  ["ր", "r"],
  ["Ր", "R"],
  ["ց", "c"],
  ["Ց", "C"],
  ["ու", "u"],
  ["ՈՒ", "U"],
  ["Ու", "U"],
  ["փ", "p"],
  ["Փ", "P"],
  ["ք", "q"],
  ["Ք", "Q"],
  ["օ", "o"],
  ["Օ", "O"],
  ["ֆ", "f"],
  ["Ֆ", "F"],
  ["և", "yev"],
  // Georgian
  ["ა", "a"],
  ["ბ", "b"],
  ["გ", "g"],
  ["დ", "d"],
  ["ე", "e"],
  ["ვ", "v"],
  ["ზ", "z"],
  ["თ", "t"],
  ["ი", "i"],
  ["კ", "k"],
  ["ლ", "l"],
  ["მ", "m"],
  ["ნ", "n"],
  ["ო", "o"],
  ["პ", "p"],
  ["ჟ", "zh"],
  ["რ", "r"],
  ["ს", "s"],
  ["ტ", "t"],
  ["უ", "u"],
  ["ფ", "ph"],
  ["ქ", "q"],
  ["ღ", "gh"],
  ["ყ", "k"],
  ["შ", "sh"],
  ["ჩ", "ch"],
  ["ც", "ts"],
  ["ძ", "dz"],
  ["წ", "ts"],
  ["ჭ", "tch"],
  ["ხ", "kh"],
  ["ჯ", "j"],
  ["ჰ", "h"],
  // Czech
  ["č", "c"],
  ["ď", "d"],
  ["ě", "e"],
  ["ň", "n"],
  ["ř", "r"],
  ["š", "s"],
  ["ť", "t"],
  ["ů", "u"],
  ["ž", "z"],
  ["Č", "C"],
  ["Ď", "D"],
  ["Ě", "E"],
  ["Ň", "N"],
  ["Ř", "R"],
  ["Š", "S"],
  ["Ť", "T"],
  ["Ů", "U"],
  ["Ž", "Z"],
  // Dhivehi
  ["ހ", "h"],
  ["ށ", "sh"],
  ["ނ", "n"],
  ["ރ", "r"],
  ["ބ", "b"],
  ["ޅ", "lh"],
  ["ކ", "k"],
  ["އ", "a"],
  ["ވ", "v"],
  ["މ", "m"],
  ["ފ", "f"],
  ["ދ", "dh"],
  ["ތ", "th"],
  ["ލ", "l"],
  ["ގ", "g"],
  ["ޏ", "gn"],
  ["ސ", "s"],
  ["ޑ", "d"],
  ["ޒ", "z"],
  ["ޓ", "t"],
  ["ޔ", "y"],
  ["ޕ", "p"],
  ["ޖ", "j"],
  ["ޗ", "ch"],
  ["ޘ", "tt"],
  ["ޙ", "hh"],
  ["ޚ", "kh"],
  ["ޛ", "th"],
  ["ޜ", "z"],
  ["ޝ", "sh"],
  ["ޞ", "s"],
  ["ޟ", "d"],
  ["ޠ", "t"],
  ["ޡ", "z"],
  ["ޢ", "a"],
  ["ޣ", "gh"],
  ["ޤ", "q"],
  ["ޥ", "w"],
  ["ަ", "a"],
  ["ާ", "aa"],
  ["ި", "i"],
  ["ީ", "ee"],
  ["ު", "u"],
  ["ޫ", "oo"],
  ["ެ", "e"],
  ["ޭ", "ey"],
  ["ޮ", "o"],
  ["ޯ", "oa"],
  ["ް", ""],
  // Greek
  ["α", "a"],
  ["β", "v"],
  ["γ", "g"],
  ["δ", "d"],
  ["ε", "e"],
  ["ζ", "z"],
  ["η", "i"],
  ["θ", "th"],
  ["ι", "i"],
  ["κ", "k"],
  ["λ", "l"],
  ["μ", "m"],
  ["ν", "n"],
  ["ξ", "ks"],
  ["ο", "o"],
  ["π", "p"],
  ["ρ", "r"],
  ["σ", "s"],
  ["τ", "t"],
  ["υ", "y"],
  ["φ", "f"],
  ["χ", "x"],
  ["ψ", "ps"],
  ["ω", "o"],
  ["ά", "a"],
  ["έ", "e"],
  ["ί", "i"],
  ["ό", "o"],
  ["ύ", "y"],
  ["ή", "i"],
  ["ώ", "o"],
  ["ς", "s"],
  ["ϊ", "i"],
  ["ΰ", "y"],
  ["ϋ", "y"],
  ["ΐ", "i"],
  ["Α", "A"],
  ["Β", "B"],
  ["Γ", "G"],
  ["Δ", "D"],
  ["Ε", "E"],
  ["Ζ", "Z"],
  ["Η", "I"],
  ["Θ", "TH"],
  ["Ι", "I"],
  ["Κ", "K"],
  ["Λ", "L"],
  ["Μ", "M"],
  ["Ν", "N"],
  ["Ξ", "KS"],
  ["Ο", "O"],
  ["Π", "P"],
  ["Ρ", "R"],
  ["Σ", "S"],
  ["Τ", "T"],
  ["Υ", "Y"],
  ["Φ", "F"],
  ["Χ", "X"],
  ["Ψ", "PS"],
  ["Ω", "O"],
  ["Ά", "A"],
  ["Έ", "E"],
  ["Ί", "I"],
  ["Ό", "O"],
  ["Ύ", "Y"],
  ["Ή", "I"],
  ["Ώ", "O"],
  ["Ϊ", "I"],
  ["Ϋ", "Y"],
  // Disabled as it conflicts with German and Latin.
  // Hungarian
  // ['ä', 'a'],
  // ['Ä', 'A'],
  // ['ö', 'o'],
  // ['Ö', 'O'],
  // ['ü', 'u'],
  // ['Ü', 'U'],
  // ['ű', 'u'],
  // ['Ű', 'U'],
  // Latvian
  ["ā", "a"],
  ["ē", "e"],
  ["ģ", "g"],
  ["ī", "i"],
  ["ķ", "k"],
  ["ļ", "l"],
  ["ņ", "n"],
  ["ū", "u"],
  ["Ā", "A"],
  ["Ē", "E"],
  ["Ģ", "G"],
  ["Ī", "I"],
  ["Ķ", "K"],
  ["Ļ", "L"],
  ["Ņ", "N"],
  ["Ū", "U"],
  ["č", "c"],
  ["š", "s"],
  ["ž", "z"],
  ["Č", "C"],
  ["Š", "S"],
  ["Ž", "Z"],
  // Lithuanian
  ["ą", "a"],
  ["č", "c"],
  ["ę", "e"],
  ["ė", "e"],
  ["į", "i"],
  ["š", "s"],
  ["ų", "u"],
  ["ū", "u"],
  ["ž", "z"],
  ["Ą", "A"],
  ["Č", "C"],
  ["Ę", "E"],
  ["Ė", "E"],
  ["Į", "I"],
  ["Š", "S"],
  ["Ų", "U"],
  ["Ū", "U"],
  // Macedonian
  ["Ќ", "Kj"],
  ["ќ", "kj"],
  ["Љ", "Lj"],
  ["љ", "lj"],
  ["Њ", "Nj"],
  ["њ", "nj"],
  ["Тс", "Ts"],
  ["тс", "ts"],
  // Polish
  ["ą", "a"],
  ["ć", "c"],
  ["ę", "e"],
  ["ł", "l"],
  ["ń", "n"],
  ["ś", "s"],
  ["ź", "z"],
  ["ż", "z"],
  ["Ą", "A"],
  ["Ć", "C"],
  ["Ę", "E"],
  ["Ł", "L"],
  ["Ń", "N"],
  ["Ś", "S"],
  ["Ź", "Z"],
  ["Ż", "Z"],
  // Disabled as it conflicts with Vietnamese.
  // Serbian
  // ['љ', 'lj'],
  // ['њ', 'nj'],
  // ['Љ', 'Lj'],
  // ['Њ', 'Nj'],
  // ['đ', 'dj'],
  // ['Đ', 'Dj'],
  // ['ђ', 'dj'],
  // ['ј', 'j'],
  // ['ћ', 'c'],
  // ['џ', 'dz'],
  // ['Ђ', 'Dj'],
  // ['Ј', 'j'],
  // ['Ћ', 'C'],
  // ['Џ', 'Dz'],
  // Disabled as it conflicts with German and Latin.
  // Slovak
  // ['ä', 'a'],
  // ['Ä', 'A'],
  // ['ľ', 'l'],
  // ['ĺ', 'l'],
  // ['ŕ', 'r'],
  // ['Ľ', 'L'],
  // ['Ĺ', 'L'],
  // ['Ŕ', 'R'],
  // Disabled as it conflicts with German and Latin.
  // Swedish
  // ['å', 'o'],
  // ['Å', 'o'],
  // ['ä', 'a'],
  // ['Ä', 'A'],
  // ['ë', 'e'],
  // ['Ë', 'E'],
  // ['ö', 'o'],
  // ['Ö', 'O'],
  // Ukrainian
  ["Є", "Ye"],
  ["І", "I"],
  ["Ї", "Yi"],
  ["Ґ", "G"],
  ["є", "ye"],
  ["і", "i"],
  ["ї", "yi"],
  ["ґ", "g"],
  // Dutch
  ["Ĳ", "IJ"],
  ["ĳ", "ij"],
  // Danish
  // ['Æ', 'Ae'],
  // ['Ø', 'Oe'],
  // ['Å', 'Aa'],
  // ['æ', 'ae'],
  // ['ø', 'oe'],
  // ['å', 'aa']
  // Currencies
  ["¢", "c"],
  ["¥", "Y"],
  ["߿", "b"],
  ["৳", "t"],
  ["૱", "Bo"],
  ["฿", "B"],
  ["₠", "CE"],
  ["₡", "C"],
  ["₢", "Cr"],
  ["₣", "F"],
  ["₥", "m"],
  ["₦", "N"],
  ["₧", "Pt"],
  ["₨", "Rs"],
  ["₩", "W"],
  ["₫", "s"],
  ["€", "E"],
  ["₭", "K"],
  ["₮", "T"],
  ["₯", "Dp"],
  ["₰", "S"],
  ["₱", "P"],
  ["₲", "G"],
  ["₳", "A"],
  ["₴", "S"],
  ["₵", "C"],
  ["₶", "tt"],
  ["₷", "S"],
  ["₸", "T"],
  ["₹", "R"],
  ["₺", "L"],
  ["₽", "P"],
  ["₿", "B"],
  ["﹩", "$"],
  ["￠", "c"],
  ["￥", "Y"],
  ["￦", "W"],
  // Latin
  ["𝐀", "A"],
  ["𝐁", "B"],
  ["𝐂", "C"],
  ["𝐃", "D"],
  ["𝐄", "E"],
  ["𝐅", "F"],
  ["𝐆", "G"],
  ["𝐇", "H"],
  ["𝐈", "I"],
  ["𝐉", "J"],
  ["𝐊", "K"],
  ["𝐋", "L"],
  ["𝐌", "M"],
  ["𝐍", "N"],
  ["𝐎", "O"],
  ["𝐏", "P"],
  ["𝐐", "Q"],
  ["𝐑", "R"],
  ["𝐒", "S"],
  ["𝐓", "T"],
  ["𝐔", "U"],
  ["𝐕", "V"],
  ["𝐖", "W"],
  ["𝐗", "X"],
  ["𝐘", "Y"],
  ["𝐙", "Z"],
  ["𝐚", "a"],
  ["𝐛", "b"],
  ["𝐜", "c"],
  ["𝐝", "d"],
  ["𝐞", "e"],
  ["𝐟", "f"],
  ["𝐠", "g"],
  ["𝐡", "h"],
  ["𝐢", "i"],
  ["𝐣", "j"],
  ["𝐤", "k"],
  ["𝐥", "l"],
  ["𝐦", "m"],
  ["𝐧", "n"],
  ["𝐨", "o"],
  ["𝐩", "p"],
  ["𝐪", "q"],
  ["𝐫", "r"],
  ["𝐬", "s"],
  ["𝐭", "t"],
  ["𝐮", "u"],
  ["𝐯", "v"],
  ["𝐰", "w"],
  ["𝐱", "x"],
  ["𝐲", "y"],
  ["𝐳", "z"],
  ["𝐴", "A"],
  ["𝐵", "B"],
  ["𝐶", "C"],
  ["𝐷", "D"],
  ["𝐸", "E"],
  ["𝐹", "F"],
  ["𝐺", "G"],
  ["𝐻", "H"],
  ["𝐼", "I"],
  ["𝐽", "J"],
  ["𝐾", "K"],
  ["𝐿", "L"],
  ["𝑀", "M"],
  ["𝑁", "N"],
  ["𝑂", "O"],
  ["𝑃", "P"],
  ["𝑄", "Q"],
  ["𝑅", "R"],
  ["𝑆", "S"],
  ["𝑇", "T"],
  ["𝑈", "U"],
  ["𝑉", "V"],
  ["𝑊", "W"],
  ["𝑋", "X"],
  ["𝑌", "Y"],
  ["𝑍", "Z"],
  ["𝑎", "a"],
  ["𝑏", "b"],
  ["𝑐", "c"],
  ["𝑑", "d"],
  ["𝑒", "e"],
  ["𝑓", "f"],
  ["𝑔", "g"],
  ["𝑖", "i"],
  ["𝑗", "j"],
  ["𝑘", "k"],
  ["𝑙", "l"],
  ["𝑚", "m"],
  ["𝑛", "n"],
  ["𝑜", "o"],
  ["𝑝", "p"],
  ["𝑞", "q"],
  ["𝑟", "r"],
  ["𝑠", "s"],
  ["𝑡", "t"],
  ["𝑢", "u"],
  ["𝑣", "v"],
  ["𝑤", "w"],
  ["𝑥", "x"],
  ["𝑦", "y"],
  ["𝑧", "z"],
  ["𝑨", "A"],
  ["𝑩", "B"],
  ["𝑪", "C"],
  ["𝑫", "D"],
  ["𝑬", "E"],
  ["𝑭", "F"],
  ["𝑮", "G"],
  ["𝑯", "H"],
  ["𝑰", "I"],
  ["𝑱", "J"],
  ["𝑲", "K"],
  ["𝑳", "L"],
  ["𝑴", "M"],
  ["𝑵", "N"],
  ["𝑶", "O"],
  ["𝑷", "P"],
  ["𝑸", "Q"],
  ["𝑹", "R"],
  ["𝑺", "S"],
  ["𝑻", "T"],
  ["𝑼", "U"],
  ["𝑽", "V"],
  ["𝑾", "W"],
  ["𝑿", "X"],
  ["𝒀", "Y"],
  ["𝒁", "Z"],
  ["𝒂", "a"],
  ["𝒃", "b"],
  ["𝒄", "c"],
  ["𝒅", "d"],
  ["𝒆", "e"],
  ["𝒇", "f"],
  ["𝒈", "g"],
  ["𝒉", "h"],
  ["𝒊", "i"],
  ["𝒋", "j"],
  ["𝒌", "k"],
  ["𝒍", "l"],
  ["𝒎", "m"],
  ["𝒏", "n"],
  ["𝒐", "o"],
  ["𝒑", "p"],
  ["𝒒", "q"],
  ["𝒓", "r"],
  ["𝒔", "s"],
  ["𝒕", "t"],
  ["𝒖", "u"],
  ["𝒗", "v"],
  ["𝒘", "w"],
  ["𝒙", "x"],
  ["𝒚", "y"],
  ["𝒛", "z"],
  ["𝒜", "A"],
  ["𝒞", "C"],
  ["𝒟", "D"],
  ["𝒢", "g"],
  ["𝒥", "J"],
  ["𝒦", "K"],
  ["𝒩", "N"],
  ["𝒪", "O"],
  ["𝒫", "P"],
  ["𝒬", "Q"],
  ["𝒮", "S"],
  ["𝒯", "T"],
  ["𝒰", "U"],
  ["𝒱", "V"],
  ["𝒲", "W"],
  ["𝒳", "X"],
  ["𝒴", "Y"],
  ["𝒵", "Z"],
  ["𝒶", "a"],
  ["𝒷", "b"],
  ["𝒸", "c"],
  ["𝒹", "d"],
  ["𝒻", "f"],
  ["𝒽", "h"],
  ["𝒾", "i"],
  ["𝒿", "j"],
  ["𝓀", "h"],
  ["𝓁", "l"],
  ["𝓂", "m"],
  ["𝓃", "n"],
  ["𝓅", "p"],
  ["𝓆", "q"],
  ["𝓇", "r"],
  ["𝓈", "s"],
  ["𝓉", "t"],
  ["𝓊", "u"],
  ["𝓋", "v"],
  ["𝓌", "w"],
  ["𝓍", "x"],
  ["𝓎", "y"],
  ["𝓏", "z"],
  ["𝓐", "A"],
  ["𝓑", "B"],
  ["𝓒", "C"],
  ["𝓓", "D"],
  ["𝓔", "E"],
  ["𝓕", "F"],
  ["𝓖", "G"],
  ["𝓗", "H"],
  ["𝓘", "I"],
  ["𝓙", "J"],
  ["𝓚", "K"],
  ["𝓛", "L"],
  ["𝓜", "M"],
  ["𝓝", "N"],
  ["𝓞", "O"],
  ["𝓟", "P"],
  ["𝓠", "Q"],
  ["𝓡", "R"],
  ["𝓢", "S"],
  ["𝓣", "T"],
  ["𝓤", "U"],
  ["𝓥", "V"],
  ["𝓦", "W"],
  ["𝓧", "X"],
  ["𝓨", "Y"],
  ["𝓩", "Z"],
  ["𝓪", "a"],
  ["𝓫", "b"],
  ["𝓬", "c"],
  ["𝓭", "d"],
  ["𝓮", "e"],
  ["𝓯", "f"],
  ["𝓰", "g"],
  ["𝓱", "h"],
  ["𝓲", "i"],
  ["𝓳", "j"],
  ["𝓴", "k"],
  ["𝓵", "l"],
  ["𝓶", "m"],
  ["𝓷", "n"],
  ["𝓸", "o"],
  ["𝓹", "p"],
  ["𝓺", "q"],
  ["𝓻", "r"],
  ["𝓼", "s"],
  ["𝓽", "t"],
  ["𝓾", "u"],
  ["𝓿", "v"],
  ["𝔀", "w"],
  ["𝔁", "x"],
  ["𝔂", "y"],
  ["𝔃", "z"],
  ["𝔄", "A"],
  ["𝔅", "B"],
  ["𝔇", "D"],
  ["𝔈", "E"],
  ["𝔉", "F"],
  ["𝔊", "G"],
  ["𝔍", "J"],
  ["𝔎", "K"],
  ["𝔏", "L"],
  ["𝔐", "M"],
  ["𝔑", "N"],
  ["𝔒", "O"],
  ["𝔓", "P"],
  ["𝔔", "Q"],
  ["𝔖", "S"],
  ["𝔗", "T"],
  ["𝔘", "U"],
  ["𝔙", "V"],
  ["𝔚", "W"],
  ["𝔛", "X"],
  ["𝔜", "Y"],
  ["𝔞", "a"],
  ["𝔟", "b"],
  ["𝔠", "c"],
  ["𝔡", "d"],
  ["𝔢", "e"],
  ["𝔣", "f"],
  ["𝔤", "g"],
  ["𝔥", "h"],
  ["𝔦", "i"],
  ["𝔧", "j"],
  ["𝔨", "k"],
  ["𝔩", "l"],
  ["𝔪", "m"],
  ["𝔫", "n"],
  ["𝔬", "o"],
  ["𝔭", "p"],
  ["𝔮", "q"],
  ["𝔯", "r"],
  ["𝔰", "s"],
  ["𝔱", "t"],
  ["𝔲", "u"],
  ["𝔳", "v"],
  ["𝔴", "w"],
  ["𝔵", "x"],
  ["𝔶", "y"],
  ["𝔷", "z"],
  ["𝔸", "A"],
  ["𝔹", "B"],
  ["𝔻", "D"],
  ["𝔼", "E"],
  ["𝔽", "F"],
  ["𝔾", "G"],
  ["𝕀", "I"],
  ["𝕁", "J"],
  ["𝕂", "K"],
  ["𝕃", "L"],
  ["𝕄", "M"],
  ["𝕆", "N"],
  ["𝕊", "S"],
  ["𝕋", "T"],
  ["𝕌", "U"],
  ["𝕍", "V"],
  ["𝕎", "W"],
  ["𝕏", "X"],
  ["𝕐", "Y"],
  ["𝕒", "a"],
  ["𝕓", "b"],
  ["𝕔", "c"],
  ["𝕕", "d"],
  ["𝕖", "e"],
  ["𝕗", "f"],
  ["𝕘", "g"],
  ["𝕙", "h"],
  ["𝕚", "i"],
  ["𝕛", "j"],
  ["𝕜", "k"],
  ["𝕝", "l"],
  ["𝕞", "m"],
  ["𝕟", "n"],
  ["𝕠", "o"],
  ["𝕡", "p"],
  ["𝕢", "q"],
  ["𝕣", "r"],
  ["𝕤", "s"],
  ["𝕥", "t"],
  ["𝕦", "u"],
  ["𝕧", "v"],
  ["𝕨", "w"],
  ["𝕩", "x"],
  ["𝕪", "y"],
  ["𝕫", "z"],
  ["𝕬", "A"],
  ["𝕭", "B"],
  ["𝕮", "C"],
  ["𝕯", "D"],
  ["𝕰", "E"],
  ["𝕱", "F"],
  ["𝕲", "G"],
  ["𝕳", "H"],
  ["𝕴", "I"],
  ["𝕵", "J"],
  ["𝕶", "K"],
  ["𝕷", "L"],
  ["𝕸", "M"],
  ["𝕹", "N"],
  ["𝕺", "O"],
  ["𝕻", "P"],
  ["𝕼", "Q"],
  ["𝕽", "R"],
  ["𝕾", "S"],
  ["𝕿", "T"],
  ["𝖀", "U"],
  ["𝖁", "V"],
  ["𝖂", "W"],
  ["𝖃", "X"],
  ["𝖄", "Y"],
  ["𝖅", "Z"],
  ["𝖆", "a"],
  ["𝖇", "b"],
  ["𝖈", "c"],
  ["𝖉", "d"],
  ["𝖊", "e"],
  ["𝖋", "f"],
  ["𝖌", "g"],
  ["𝖍", "h"],
  ["𝖎", "i"],
  ["𝖏", "j"],
  ["𝖐", "k"],
  ["𝖑", "l"],
  ["𝖒", "m"],
  ["𝖓", "n"],
  ["𝖔", "o"],
  ["𝖕", "p"],
  ["𝖖", "q"],
  ["𝖗", "r"],
  ["𝖘", "s"],
  ["𝖙", "t"],
  ["𝖚", "u"],
  ["𝖛", "v"],
  ["𝖜", "w"],
  ["𝖝", "x"],
  ["𝖞", "y"],
  ["𝖟", "z"],
  ["𝖠", "A"],
  ["𝖡", "B"],
  ["𝖢", "C"],
  ["𝖣", "D"],
  ["𝖤", "E"],
  ["𝖥", "F"],
  ["𝖦", "G"],
  ["𝖧", "H"],
  ["𝖨", "I"],
  ["𝖩", "J"],
  ["𝖪", "K"],
  ["𝖫", "L"],
  ["𝖬", "M"],
  ["𝖭", "N"],
  ["𝖮", "O"],
  ["𝖯", "P"],
  ["𝖰", "Q"],
  ["𝖱", "R"],
  ["𝖲", "S"],
  ["𝖳", "T"],
  ["𝖴", "U"],
  ["𝖵", "V"],
  ["𝖶", "W"],
  ["𝖷", "X"],
  ["𝖸", "Y"],
  ["𝖹", "Z"],
  ["𝖺", "a"],
  ["𝖻", "b"],
  ["𝖼", "c"],
  ["𝖽", "d"],
  ["𝖾", "e"],
  ["𝖿", "f"],
  ["𝗀", "g"],
  ["𝗁", "h"],
  ["𝗂", "i"],
  ["𝗃", "j"],
  ["𝗄", "k"],
  ["𝗅", "l"],
  ["𝗆", "m"],
  ["𝗇", "n"],
  ["𝗈", "o"],
  ["𝗉", "p"],
  ["𝗊", "q"],
  ["𝗋", "r"],
  ["𝗌", "s"],
  ["𝗍", "t"],
  ["𝗎", "u"],
  ["𝗏", "v"],
  ["𝗐", "w"],
  ["𝗑", "x"],
  ["𝗒", "y"],
  ["𝗓", "z"],
  ["𝗔", "A"],
  ["𝗕", "B"],
  ["𝗖", "C"],
  ["𝗗", "D"],
  ["𝗘", "E"],
  ["𝗙", "F"],
  ["𝗚", "G"],
  ["𝗛", "H"],
  ["𝗜", "I"],
  ["𝗝", "J"],
  ["𝗞", "K"],
  ["𝗟", "L"],
  ["𝗠", "M"],
  ["𝗡", "N"],
  ["𝗢", "O"],
  ["𝗣", "P"],
  ["𝗤", "Q"],
  ["𝗥", "R"],
  ["𝗦", "S"],
  ["𝗧", "T"],
  ["𝗨", "U"],
  ["𝗩", "V"],
  ["𝗪", "W"],
  ["𝗫", "X"],
  ["𝗬", "Y"],
  ["𝗭", "Z"],
  ["𝗮", "a"],
  ["𝗯", "b"],
  ["𝗰", "c"],
  ["𝗱", "d"],
  ["𝗲", "e"],
  ["𝗳", "f"],
  ["𝗴", "g"],
  ["𝗵", "h"],
  ["𝗶", "i"],
  ["𝗷", "j"],
  ["𝗸", "k"],
  ["𝗹", "l"],
  ["𝗺", "m"],
  ["𝗻", "n"],
  ["𝗼", "o"],
  ["𝗽", "p"],
  ["𝗾", "q"],
  ["𝗿", "r"],
  ["𝘀", "s"],
  ["𝘁", "t"],
  ["𝘂", "u"],
  ["𝘃", "v"],
  ["𝘄", "w"],
  ["𝘅", "x"],
  ["𝘆", "y"],
  ["𝘇", "z"],
  ["𝘈", "A"],
  ["𝘉", "B"],
  ["𝘊", "C"],
  ["𝘋", "D"],
  ["𝘌", "E"],
  ["𝘍", "F"],
  ["𝘎", "G"],
  ["𝘏", "H"],
  ["𝘐", "I"],
  ["𝘑", "J"],
  ["𝘒", "K"],
  ["𝘓", "L"],
  ["𝘔", "M"],
  ["𝘕", "N"],
  ["𝘖", "O"],
  ["𝘗", "P"],
  ["𝘘", "Q"],
  ["𝘙", "R"],
  ["𝘚", "S"],
  ["𝘛", "T"],
  ["𝘜", "U"],
  ["𝘝", "V"],
  ["𝘞", "W"],
  ["𝘟", "X"],
  ["𝘠", "Y"],
  ["𝘡", "Z"],
  ["𝘢", "a"],
  ["𝘣", "b"],
  ["𝘤", "c"],
  ["𝘥", "d"],
  ["𝘦", "e"],
  ["𝘧", "f"],
  ["𝘨", "g"],
  ["𝘩", "h"],
  ["𝘪", "i"],
  ["𝘫", "j"],
  ["𝘬", "k"],
  ["𝘭", "l"],
  ["𝘮", "m"],
  ["𝘯", "n"],
  ["𝘰", "o"],
  ["𝘱", "p"],
  ["𝘲", "q"],
  ["𝘳", "r"],
  ["𝘴", "s"],
  ["𝘵", "t"],
  ["𝘶", "u"],
  ["𝘷", "v"],
  ["𝘸", "w"],
  ["𝘹", "x"],
  ["𝘺", "y"],
  ["𝘻", "z"],
  ["𝘼", "A"],
  ["𝘽", "B"],
  ["𝘾", "C"],
  ["𝘿", "D"],
  ["𝙀", "E"],
  ["𝙁", "F"],
  ["𝙂", "G"],
  ["𝙃", "H"],
  ["𝙄", "I"],
  ["𝙅", "J"],
  ["𝙆", "K"],
  ["𝙇", "L"],
  ["𝙈", "M"],
  ["𝙉", "N"],
  ["𝙊", "O"],
  ["𝙋", "P"],
  ["𝙌", "Q"],
  ["𝙍", "R"],
  ["𝙎", "S"],
  ["𝙏", "T"],
  ["𝙐", "U"],
  ["𝙑", "V"],
  ["𝙒", "W"],
  ["𝙓", "X"],
  ["𝙔", "Y"],
  ["𝙕", "Z"],
  ["𝙖", "a"],
  ["𝙗", "b"],
  ["𝙘", "c"],
  ["𝙙", "d"],
  ["𝙚", "e"],
  ["𝙛", "f"],
  ["𝙜", "g"],
  ["𝙝", "h"],
  ["𝙞", "i"],
  ["𝙟", "j"],
  ["𝙠", "k"],
  ["𝙡", "l"],
  ["𝙢", "m"],
  ["𝙣", "n"],
  ["𝙤", "o"],
  ["𝙥", "p"],
  ["𝙦", "q"],
  ["𝙧", "r"],
  ["𝙨", "s"],
  ["𝙩", "t"],
  ["𝙪", "u"],
  ["𝙫", "v"],
  ["𝙬", "w"],
  ["𝙭", "x"],
  ["𝙮", "y"],
  ["𝙯", "z"],
  ["𝙰", "A"],
  ["𝙱", "B"],
  ["𝙲", "C"],
  ["𝙳", "D"],
  ["𝙴", "E"],
  ["𝙵", "F"],
  ["𝙶", "G"],
  ["𝙷", "H"],
  ["𝙸", "I"],
  ["𝙹", "J"],
  ["𝙺", "K"],
  ["𝙻", "L"],
  ["𝙼", "M"],
  ["𝙽", "N"],
  ["𝙾", "O"],
  ["𝙿", "P"],
  ["𝚀", "Q"],
  ["𝚁", "R"],
  ["𝚂", "S"],
  ["𝚃", "T"],
  ["𝚄", "U"],
  ["𝚅", "V"],
  ["𝚆", "W"],
  ["𝚇", "X"],
  ["𝚈", "Y"],
  ["𝚉", "Z"],
  ["𝚊", "a"],
  ["𝚋", "b"],
  ["𝚌", "c"],
  ["𝚍", "d"],
  ["𝚎", "e"],
  ["𝚏", "f"],
  ["𝚐", "g"],
  ["𝚑", "h"],
  ["𝚒", "i"],
  ["𝚓", "j"],
  ["𝚔", "k"],
  ["𝚕", "l"],
  ["𝚖", "m"],
  ["𝚗", "n"],
  ["𝚘", "o"],
  ["𝚙", "p"],
  ["𝚚", "q"],
  ["𝚛", "r"],
  ["𝚜", "s"],
  ["𝚝", "t"],
  ["𝚞", "u"],
  ["𝚟", "v"],
  ["𝚠", "w"],
  ["𝚡", "x"],
  ["𝚢", "y"],
  ["𝚣", "z"],
  // Dotless letters
  ["𝚤", "l"],
  ["𝚥", "j"],
  // Greek
  ["𝛢", "A"],
  ["𝛣", "B"],
  ["𝛤", "G"],
  ["𝛥", "D"],
  ["𝛦", "E"],
  ["𝛧", "Z"],
  ["𝛨", "I"],
  ["𝛩", "TH"],
  ["𝛪", "I"],
  ["𝛫", "K"],
  ["𝛬", "L"],
  ["𝛭", "M"],
  ["𝛮", "N"],
  ["𝛯", "KS"],
  ["𝛰", "O"],
  ["𝛱", "P"],
  ["𝛲", "R"],
  ["𝛳", "TH"],
  ["𝛴", "S"],
  ["𝛵", "T"],
  ["𝛶", "Y"],
  ["𝛷", "F"],
  ["𝛸", "x"],
  ["𝛹", "PS"],
  ["𝛺", "O"],
  ["𝛻", "D"],
  ["𝛼", "a"],
  ["𝛽", "b"],
  ["𝛾", "g"],
  ["𝛿", "d"],
  ["𝜀", "e"],
  ["𝜁", "z"],
  ["𝜂", "i"],
  ["𝜃", "th"],
  ["𝜄", "i"],
  ["𝜅", "k"],
  ["𝜆", "l"],
  ["𝜇", "m"],
  ["𝜈", "n"],
  ["𝜉", "ks"],
  ["𝜊", "o"],
  ["𝜋", "p"],
  ["𝜌", "r"],
  ["𝜍", "s"],
  ["𝜎", "s"],
  ["𝜏", "t"],
  ["𝜐", "y"],
  ["𝜑", "f"],
  ["𝜒", "x"],
  ["𝜓", "ps"],
  ["𝜔", "o"],
  ["𝜕", "d"],
  ["𝜖", "E"],
  ["𝜗", "TH"],
  ["𝜘", "K"],
  ["𝜙", "f"],
  ["𝜚", "r"],
  ["𝜛", "p"],
  ["𝜜", "A"],
  ["𝜝", "V"],
  ["𝜞", "G"],
  ["𝜟", "D"],
  ["𝜠", "E"],
  ["𝜡", "Z"],
  ["𝜢", "I"],
  ["𝜣", "TH"],
  ["𝜤", "I"],
  ["𝜥", "K"],
  ["𝜦", "L"],
  ["𝜧", "M"],
  ["𝜨", "N"],
  ["𝜩", "KS"],
  ["𝜪", "O"],
  ["𝜫", "P"],
  ["𝜬", "S"],
  ["𝜭", "TH"],
  ["𝜮", "S"],
  ["𝜯", "T"],
  ["𝜰", "Y"],
  ["𝜱", "F"],
  ["𝜲", "X"],
  ["𝜳", "PS"],
  ["𝜴", "O"],
  ["𝜵", "D"],
  ["𝜶", "a"],
  ["𝜷", "v"],
  ["𝜸", "g"],
  ["𝜹", "d"],
  ["𝜺", "e"],
  ["𝜻", "z"],
  ["𝜼", "i"],
  ["𝜽", "th"],
  ["𝜾", "i"],
  ["𝜿", "k"],
  ["𝝀", "l"],
  ["𝝁", "m"],
  ["𝝂", "n"],
  ["𝝃", "ks"],
  ["𝝄", "o"],
  ["𝝅", "p"],
  ["𝝆", "r"],
  ["𝝇", "s"],
  ["𝝈", "s"],
  ["𝝉", "t"],
  ["𝝊", "y"],
  ["𝝋", "f"],
  ["𝝌", "x"],
  ["𝝍", "ps"],
  ["𝝎", "o"],
  ["𝝏", "a"],
  ["𝝐", "e"],
  ["𝝑", "i"],
  ["𝝒", "k"],
  ["𝝓", "f"],
  ["𝝔", "r"],
  ["𝝕", "p"],
  ["𝝖", "A"],
  ["𝝗", "B"],
  ["𝝘", "G"],
  ["𝝙", "D"],
  ["𝝚", "E"],
  ["𝝛", "Z"],
  ["𝝜", "I"],
  ["𝝝", "TH"],
  ["𝝞", "I"],
  ["𝝟", "K"],
  ["𝝠", "L"],
  ["𝝡", "M"],
  ["𝝢", "N"],
  ["𝝣", "KS"],
  ["𝝤", "O"],
  ["𝝥", "P"],
  ["𝝦", "R"],
  ["𝝧", "TH"],
  ["𝝨", "S"],
  ["𝝩", "T"],
  ["𝝪", "Y"],
  ["𝝫", "F"],
  ["𝝬", "X"],
  ["𝝭", "PS"],
  ["𝝮", "O"],
  ["𝝯", "D"],
  ["𝝰", "a"],
  ["𝝱", "v"],
  ["𝝲", "g"],
  ["𝝳", "d"],
  ["𝝴", "e"],
  ["𝝵", "z"],
  ["𝝶", "i"],
  ["𝝷", "th"],
  ["𝝸", "i"],
  ["𝝹", "k"],
  ["𝝺", "l"],
  ["𝝻", "m"],
  ["𝝼", "n"],
  ["𝝽", "ks"],
  ["𝝾", "o"],
  ["𝝿", "p"],
  ["𝞀", "r"],
  ["𝞁", "s"],
  ["𝞂", "s"],
  ["𝞃", "t"],
  ["𝞄", "y"],
  ["𝞅", "f"],
  ["𝞆", "x"],
  ["𝞇", "ps"],
  ["𝞈", "o"],
  ["𝞉", "a"],
  ["𝞊", "e"],
  ["𝞋", "i"],
  ["𝞌", "k"],
  ["𝞍", "f"],
  ["𝞎", "r"],
  ["𝞏", "p"],
  ["𝞐", "A"],
  ["𝞑", "V"],
  ["𝞒", "G"],
  ["𝞓", "D"],
  ["𝞔", "E"],
  ["𝞕", "Z"],
  ["𝞖", "I"],
  ["𝞗", "TH"],
  ["𝞘", "I"],
  ["𝞙", "K"],
  ["𝞚", "L"],
  ["𝞛", "M"],
  ["𝞜", "N"],
  ["𝞝", "KS"],
  ["𝞞", "O"],
  ["𝞟", "P"],
  ["𝞠", "S"],
  ["𝞡", "TH"],
  ["𝞢", "S"],
  ["𝞣", "T"],
  ["𝞤", "Y"],
  ["𝞥", "F"],
  ["𝞦", "X"],
  ["𝞧", "PS"],
  ["𝞨", "O"],
  ["𝞩", "D"],
  ["𝞪", "av"],
  ["𝞫", "g"],
  ["𝞬", "d"],
  ["𝞭", "e"],
  ["𝞮", "z"],
  ["𝞯", "i"],
  ["𝞰", "i"],
  ["𝞱", "th"],
  ["𝞲", "i"],
  ["𝞳", "k"],
  ["𝞴", "l"],
  ["𝞵", "m"],
  ["𝞶", "n"],
  ["𝞷", "ks"],
  ["𝞸", "o"],
  ["𝞹", "p"],
  ["𝞺", "r"],
  ["𝞻", "s"],
  ["𝞼", "s"],
  ["𝞽", "t"],
  ["𝞾", "y"],
  ["𝞿", "f"],
  ["𝟀", "x"],
  ["𝟁", "ps"],
  ["𝟂", "o"],
  ["𝟃", "a"],
  ["𝟄", "e"],
  ["𝟅", "i"],
  ["𝟆", "k"],
  ["𝟇", "f"],
  ["𝟈", "r"],
  ["𝟉", "p"],
  ["𝟊", "F"],
  ["𝟋", "f"],
  ["⒜", "(a)"],
  ["⒝", "(b)"],
  ["⒞", "(c)"],
  ["⒟", "(d)"],
  ["⒠", "(e)"],
  ["⒡", "(f)"],
  ["⒢", "(g)"],
  ["⒣", "(h)"],
  ["⒤", "(i)"],
  ["⒥", "(j)"],
  ["⒦", "(k)"],
  ["⒧", "(l)"],
  ["⒨", "(m)"],
  ["⒩", "(n)"],
  ["⒪", "(o)"],
  ["⒫", "(p)"],
  ["⒬", "(q)"],
  ["⒭", "(r)"],
  ["⒮", "(s)"],
  ["⒯", "(t)"],
  ["⒰", "(u)"],
  ["⒱", "(v)"],
  ["⒲", "(w)"],
  ["⒳", "(x)"],
  ["⒴", "(y)"],
  ["⒵", "(z)"],
  ["Ⓐ", "(A)"],
  ["Ⓑ", "(B)"],
  ["Ⓒ", "(C)"],
  ["Ⓓ", "(D)"],
  ["Ⓔ", "(E)"],
  ["Ⓕ", "(F)"],
  ["Ⓖ", "(G)"],
  ["Ⓗ", "(H)"],
  ["Ⓘ", "(I)"],
  ["Ⓙ", "(J)"],
  ["Ⓚ", "(K)"],
  ["Ⓛ", "(L)"],
  ["Ⓝ", "(N)"],
  ["Ⓞ", "(O)"],
  ["Ⓟ", "(P)"],
  ["Ⓠ", "(Q)"],
  ["Ⓡ", "(R)"],
  ["Ⓢ", "(S)"],
  ["Ⓣ", "(T)"],
  ["Ⓤ", "(U)"],
  ["Ⓥ", "(V)"],
  ["Ⓦ", "(W)"],
  ["Ⓧ", "(X)"],
  ["Ⓨ", "(Y)"],
  ["Ⓩ", "(Z)"],
  ["ⓐ", "(a)"],
  ["ⓑ", "(b)"],
  ["ⓒ", "(b)"],
  ["ⓓ", "(c)"],
  ["ⓔ", "(e)"],
  ["ⓕ", "(f)"],
  ["ⓖ", "(g)"],
  ["ⓗ", "(h)"],
  ["ⓘ", "(i)"],
  ["ⓙ", "(j)"],
  ["ⓚ", "(k)"],
  ["ⓛ", "(l)"],
  ["ⓜ", "(m)"],
  ["ⓝ", "(n)"],
  ["ⓞ", "(o)"],
  ["ⓟ", "(p)"],
  ["ⓠ", "(q)"],
  ["ⓡ", "(r)"],
  ["ⓢ", "(s)"],
  ["ⓣ", "(t)"],
  ["ⓤ", "(u)"],
  ["ⓥ", "(v)"],
  ["ⓦ", "(w)"],
  ["ⓧ", "(x)"],
  ["ⓨ", "(y)"],
  ["ⓩ", "(z)"],
  // Maltese
  ["Ċ", "C"],
  ["ċ", "c"],
  ["Ġ", "G"],
  ["ġ", "g"],
  ["Ħ", "H"],
  ["ħ", "h"],
  ["Ż", "Z"],
  ["ż", "z"],
  // Numbers
  ["𝟎", "0"],
  ["𝟏", "1"],
  ["𝟐", "2"],
  ["𝟑", "3"],
  ["𝟒", "4"],
  ["𝟓", "5"],
  ["𝟔", "6"],
  ["𝟕", "7"],
  ["𝟖", "8"],
  ["𝟗", "9"],
  ["𝟘", "0"],
  ["𝟙", "1"],
  ["𝟚", "2"],
  ["𝟛", "3"],
  ["𝟜", "4"],
  ["𝟝", "5"],
  ["𝟞", "6"],
  ["𝟟", "7"],
  ["𝟠", "8"],
  ["𝟡", "9"],
  ["𝟢", "0"],
  ["𝟣", "1"],
  ["𝟤", "2"],
  ["𝟥", "3"],
  ["𝟦", "4"],
  ["𝟧", "5"],
  ["𝟨", "6"],
  ["𝟩", "7"],
  ["𝟪", "8"],
  ["𝟫", "9"],
  ["𝟬", "0"],
  ["𝟭", "1"],
  ["𝟮", "2"],
  ["𝟯", "3"],
  ["𝟰", "4"],
  ["𝟱", "5"],
  ["𝟲", "6"],
  ["𝟳", "7"],
  ["𝟴", "8"],
  ["𝟵", "9"],
  ["𝟶", "0"],
  ["𝟷", "1"],
  ["𝟸", "2"],
  ["𝟹", "3"],
  ["𝟺", "4"],
  ["𝟻", "5"],
  ["𝟼", "6"],
  ["𝟽", "7"],
  ["𝟾", "8"],
  ["𝟿", "9"],
  ["①", "1"],
  ["②", "2"],
  ["③", "3"],
  ["④", "4"],
  ["⑤", "5"],
  ["⑥", "6"],
  ["⑦", "7"],
  ["⑧", "8"],
  ["⑨", "9"],
  ["⑩", "10"],
  ["⑪", "11"],
  ["⑫", "12"],
  ["⑬", "13"],
  ["⑭", "14"],
  ["⑮", "15"],
  ["⑯", "16"],
  ["⑰", "17"],
  ["⑱", "18"],
  ["⑲", "19"],
  ["⑳", "20"],
  ["⑴", "1"],
  ["⑵", "2"],
  ["⑶", "3"],
  ["⑷", "4"],
  ["⑸", "5"],
  ["⑹", "6"],
  ["⑺", "7"],
  ["⑻", "8"],
  ["⑼", "9"],
  ["⑽", "10"],
  ["⑾", "11"],
  ["⑿", "12"],
  ["⒀", "13"],
  ["⒁", "14"],
  ["⒂", "15"],
  ["⒃", "16"],
  ["⒄", "17"],
  ["⒅", "18"],
  ["⒆", "19"],
  ["⒇", "20"],
  ["⒈", "1."],
  ["⒉", "2."],
  ["⒊", "3."],
  ["⒋", "4."],
  ["⒌", "5."],
  ["⒍", "6."],
  ["⒎", "7."],
  ["⒏", "8."],
  ["⒐", "9."],
  ["⒑", "10."],
  ["⒒", "11."],
  ["⒓", "12."],
  ["⒔", "13."],
  ["⒕", "14."],
  ["⒖", "15."],
  ["⒗", "16."],
  ["⒘", "17."],
  ["⒙", "18."],
  ["⒚", "19."],
  ["⒛", "20."],
  ["⓪", "0"],
  ["⓫", "11"],
  ["⓬", "12"],
  ["⓭", "13"],
  ["⓮", "14"],
  ["⓯", "15"],
  ["⓰", "16"],
  ["⓱", "17"],
  ["⓲", "18"],
  ["⓳", "19"],
  ["⓴", "20"],
  ["⓵", "1"],
  ["⓶", "2"],
  ["⓷", "3"],
  ["⓸", "4"],
  ["⓹", "5"],
  ["⓺", "6"],
  ["⓻", "7"],
  ["⓼", "8"],
  ["⓽", "9"],
  ["⓾", "10"],
  ["⓿", "0"],
  // Punctuation
  ["🙰", "&"],
  ["🙱", "&"],
  ["🙲", "&"],
  ["🙳", "&"],
  ["🙴", "&"],
  ["🙵", "&"],
  ["🙶", '"'],
  ["🙷", '"'],
  ["🙸", '"'],
  ["‽", "?!"],
  ["🙹", "?!"],
  ["🙺", "?!"],
  ["🙻", "?!"],
  ["🙼", "/"],
  ["🙽", "\\"],
  // Alchemy
  ["🜇", "AR"],
  ["🜈", "V"],
  ["🜉", "V"],
  ["🜆", "VR"],
  ["🜅", "VF"],
  ["🜩", "2"],
  ["🜪", "5"],
  ["🝡", "f"],
  ["🝢", "W"],
  ["🝣", "U"],
  ["🝧", "V"],
  ["🝨", "T"],
  ["🝪", "V"],
  ["🝫", "MB"],
  ["🝬", "VB"],
  ["🝲", "3B"],
  ["🝳", "3B"],
  // Emojis
  ["💯", "100"],
  ["🔙", "BACK"],
  ["🔚", "END"],
  ["🔛", "ON!"],
  ["🔜", "SOON"],
  ["🔝", "TOP"],
  ["🔞", "18"],
  ["🔤", "abc"],
  ["🔠", "ABCD"],
  ["🔡", "abcd"],
  ["🔢", "1234"],
  ["🔣", "T&@%"],
  ["#️⃣", "#"],
  ["*️⃣", "*"],
  ["0️⃣", "0"],
  ["1️⃣", "1"],
  ["2️⃣", "2"],
  ["3️⃣", "3"],
  ["4️⃣", "4"],
  ["5️⃣", "5"],
  ["6️⃣", "6"],
  ["7️⃣", "7"],
  ["8️⃣", "8"],
  ["9️⃣", "9"],
  ["🔟", "10"],
  ["🅰️", "A"],
  ["🅱️", "B"],
  ["🆎", "AB"],
  ["🆑", "CL"],
  ["🅾️", "O"],
  ["🅿", "P"],
  ["🆘", "SOS"],
  ["🅲", "C"],
  ["🅳", "D"],
  ["🅴", "E"],
  ["🅵", "F"],
  ["🅶", "G"],
  ["🅷", "H"],
  ["🅸", "I"],
  ["🅹", "J"],
  ["🅺", "K"],
  ["🅻", "L"],
  ["🅼", "M"],
  ["🅽", "N"],
  ["🆀", "Q"],
  ["🆁", "R"],
  ["🆂", "S"],
  ["🆃", "T"],
  ["🆄", "U"],
  ["🆅", "V"],
  ["🆆", "W"],
  ["🆇", "X"],
  ["🆈", "Y"],
  ["🆉", "Z"]
];
var replacements_default = replacements;

// node_modules/@sindresorhus/transliterate/index.js
var doCustomReplacements = (string, replacements2) => {
  for (const [key, value] of replacements2) {
    string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
  }
  return string;
};
function transliterate(string, options) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string}\``);
  }
  options = {
    customReplacements: [],
    ...options
  };
  const customReplacements = new Map([
    ...replacements_default,
    ...options.customReplacements
  ]);
  string = string.normalize();
  string = doCustomReplacements(string, customReplacements);
  string = string.normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").normalize();
  return string;
}

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var overridableReplacements = [
  ["&", " and "],
  ["🦄", " unicorn "],
  ["♥", " love "]
];
var overridable_replacements_default = overridableReplacements;

// node_modules/@sindresorhus/slugify/index.js
var decamelize = (string) => {
  return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-rt-z\d]+)/g, "$1 $2");
};
var removeMootSeparators = (string, separator) => {
  const escapedSeparator = escapeStringRegexp(separator);
  return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
};
var buildPatternSlug = (options) => {
  let negationSetPattern = "a-z\\d";
  negationSetPattern += options.lowercase ? "" : "A-Z";
  if (options.preserveCharacters.length > 0) {
    for (const character of options.preserveCharacters) {
      if (character === options.separator) {
        throw new Error(`The separator character \`${options.separator}\` cannot be included in preserved characters: ${options.preserveCharacters}`);
      }
      negationSetPattern += escapeStringRegexp(character);
    }
  }
  return new RegExp(`[^${negationSetPattern}]+`, "g");
};
function slugify(string, options) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a string, got \`${typeof string}\``);
  }
  options = {
    separator: "-",
    lowercase: true,
    decamelize: true,
    customReplacements: [],
    preserveLeadingUnderscore: false,
    preserveTrailingDash: false,
    preserveCharacters: [],
    ...options
  };
  const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
  const shouldAppendDash = options.preserveTrailingDash && string.endsWith("-");
  const customReplacements = new Map([
    ...overridable_replacements_default,
    ...options.customReplacements
  ]);
  string = transliterate(string, { customReplacements });
  if (options.decamelize) {
    string = decamelize(string);
  }
  const patternSlug = buildPatternSlug(options);
  if (options.lowercase) {
    string = string.toLowerCase();
  }
  string = string.replace(/([a-zA-Z\d]+)'([ts])(\s|$)/g, "$1$2$3");
  string = string.replace(patternSlug, options.separator);
  string = string.replace(/\\/g, "");
  if (options.separator) {
    string = removeMootSeparators(string, options.separator);
  }
  if (shouldPrependUnderscore) {
    string = `_${string}`;
  }
  if (shouldAppendDash) {
    string = `${string}-`;
  }
  return string;
}

// node_modules/prosemirror-schema-list/dist/index.js
function splitListItem(itemType, itemAttrs) {
  return function(state, dispatch) {
    let { $from, $to, node } = state.selection;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to))
      return false;
    let grandParent = $from.node(-1);
    if (grandParent.type != itemType)
      return false;
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1)
        return false;
      if (dispatch) {
        let wrap = Fragment.empty;
        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)
          wrap = Fragment.from($from.node(d).copy(wrap));
        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap = wrap.append(Fragment.from(itemType.createAndFill()));
        let start = $from.before($from.depth - (depthBefore - 1));
        let tr2 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
        let sel = -1;
        tr2.doc.nodesBetween(start, tr2.doc.content.size, (node2, pos) => {
          if (sel > -1)
            return false;
          if (node2.isTextblock && node2.content.size == 0)
            sel = pos + 1;
        });
        if (sel > -1)
          tr2.setSelection(Selection.near(tr2.doc.resolve(sel)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    let tr = state.tr.delete($from.pos, $to.pos);
    let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : void 0;
    if (!canSplit(tr.doc, $from.pos, 2, types))
      return false;
    if (dispatch)
      dispatch(tr.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let after = tr.mapping.map(end, -1) - 1;
  if (canJoin(tr.doc, after))
    tr.join(after);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/mdast-util-definitions/lib/index.js
function definitions(tree) {
  const cache = /* @__PURE__ */ new Map();
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit(tree, "definition", function(definition2) {
    const id = clean(definition2.identifier);
    if (id && !cache.get(id)) {
      cache.set(id, definition2);
    }
  });
  return definition;
  function definition(identifier) {
    const id = clean(identifier);
    return cache.get(id);
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}

// node_modules/remark-inline-links/lib/index.js
function remarkInlineLinks() {
  return function(tree) {
    const definition = definitions(tree);
    visit(tree, function(node, index, parent) {
      if (node.type === "definition" && parent !== void 0 && typeof index === "number") {
        parent.children.splice(index, 1);
        return [SKIP, index];
      }
      if (node.type === "imageReference" || node.type === "linkReference") {
        const def = definition(node.identifier);
        if (def && parent && typeof index === "number") {
          parent.children[index] = node.type === "imageReference" ? { type: "image", url: def.url, title: def.title, alt: node.alt } : {
            type: "link",
            url: def.url,
            title: def.title,
            children: node.children
          };
          return [SKIP, index];
        }
      }
    });
  };
}

// node_modules/@milkdown/preset-commonmark/lib/index.es.js
function at(t, e) {
  var o;
  if (!(e.childCount >= 1 && ((o = e.lastChild) == null ? void 0 : o.type.name) === "hardbreak")) {
    t.next(e.content);
    return;
  }
  const a = [];
  e.content.forEach((s, l, i) => {
    i !== e.childCount - 1 && a.push(s);
  }), t.next(Fragment.fromArray(a));
}
function n(t, e) {
  return Object.assign(t, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), t;
}
var ee = we("emphasis");
n(ee, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
var R = ye("emphasis", (t) => ({
  attrs: {
    marker: {
      default: t.get(Q).emphasis || "*"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", t.get(ee.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, r) => {
      e.withMark(r, "emphasis", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n(R.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
n(R.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
var te = re("ToggleEmphasis", (t) => () => toggleMark(R.type(t)));
n(te, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
var nt = oe((t) => markRule(/(?:^|[^*])\*([^*]+)\*$/, R.type(t), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: r }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: r + 1 }
}));
n(nt, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
var ot = oe((t) => markRule(/(?:^|[^_])_([^_]+)_$/, R.type(t), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: r }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: r + 1 }
}));
n(ot, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
var re2 = ge("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(te.key);
    }
  }
});
n(re2.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
n(re2.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
var ae = we("strong");
n(ae, {
  displayName: "Attr<strong>",
  group: "Strong"
});
var $ = ye("strong", (t) => ({
  attrs: {
    marker: {
      default: t.get(Q).strong || "*"
    }
  },
  parseDOM: [
    { tag: "b" },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" }
  ],
  toDOM: (e) => ["strong", t.get(ae.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, r) => {
      e.withMark(r, "strong", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n($.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
n($.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
var ne = re("ToggleStrong", (t) => () => toggleMark($.type(t)));
n(ne, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
var st = oe((t) => markRule(/(?:\*\*|__)([^*_]+)(?:\*\*|__)$/, $.type(t), {
  getAttr: (e) => ({
    marker: e[0].startsWith("*") ? "*" : "_"
  })
}));
n(st, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
var oe2 = ge("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(ne.key);
    }
  }
});
n(oe2.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
n(oe2.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
var se = we("inlineCode");
n(se, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
var x = ye("inlineCode", (t) => ({
  priority: 100,
  code: true,
  inclusive: false,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", t.get(se.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, r, a) => {
      e.openMark(a), e.addText(r.value), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, r, a) => {
      e.withMark(r, "inlineCode", a.text || "");
    }
  }
}));
n(x.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
n(x.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
var le = re("ToggleInlineCode", (t) => () => (e, r) => {
  const { selection: a, tr: o } = e;
  if (a.empty)
    return false;
  const { from: s, to: l } = a;
  return e.doc.rangeHasMark(s, l, x.type(t)) ? (r == null || r(o.removeMark(s, l, x.type(t))), true) : (Object.keys(e.schema.marks).filter((m) => m !== x.type.name).map((m) => e.schema.marks[m]).forEach((m) => {
    o.removeMark(s, l, m);
  }), r == null || r(o.addMark(s, l, x.type(t).create())), true);
});
n(le, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
var lt = oe((t) => markRule(/(?:\`)([^\`]+)(?:\`)$/, x.type(t)));
n(lt, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
var ie = ge("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(le.key);
    }
  }
});
n(ie.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
n(ie.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
var de = we("link");
n(de, {
  displayName: "Attr<link>",
  group: "Link"
});
var B = ye("link", (t) => ({
  attrs: {
    href: {},
    title: { default: null }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { href: e.getAttribute("href"), title: e.getAttribute("title") };
      }
    }
  ],
  toDOM: (e) => ["a", { ...t.get(de.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, r, a) => {
      const o = r.url, s = r.title;
      e.openMark(a, { href: o, title: s }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, r) => {
      e.withMark(r, "link", void 0, {
        title: r.attrs.title,
        url: r.attrs.href
      });
    }
  }
}));
n(B.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
var it = re("ToggleLink", (t) => (e = {}) => toggleMark(B.type(t), e));
n(it, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
var dt = re("UpdateLink", (t) => (e = {}) => (r, a) => {
  if (!a)
    return false;
  let o, s = -1;
  const { selection: l } = r, { from: i, to: d } = l;
  if (r.doc.nodesBetween(i, i === d ? d + 1 : d, (k, b) => {
    if (B.type(t).isInSet(k.marks))
      return o = k, s = b, false;
  }), !o)
    return false;
  const m = o.marks.find(({ type: k }) => k === B.type(t));
  if (!m)
    return false;
  const p = s, y = s + o.nodeSize, { tr: g } = r, C = B.type(t).create({ ...m.attrs, ...e });
  return C ? (a(
    g.removeMark(p, y, m).addMark(p, y, C).setSelection(new TextSelection(g.selection.$anchor)).scrollIntoView()
  ), true) : false;
});
n(dt, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
var mt = W("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: t }) => t === "root",
    runner: (t, e, r) => {
      t.injectRoot(e, r);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "doc",
    runner: (t, e) => {
      t.openNode("root"), t.next(e.content);
    }
  }
}));
n(mt, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
var me = he("paragraph");
n(me, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
var w = fe("paragraph", (t) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", t.get(me.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, r, a) => {
      e.openNode(a), r.children ? e.next(r.children) : e.addText(r.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, r) => {
      e.openNode("paragraph"), at(e, r), e.closeNode();
    }
  }
}));
n(w.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
n(w.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
var pe = re("TurnIntoText", (t) => () => setBlockType(w.type(t)));
n(pe, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
var ce = ge("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(pe.key);
    }
  }
});
n(ce.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
n(ce.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
var Dt = Array(6).fill(0).map((t, e) => e + 1);
function _t(t) {
  return slugify(t.textContent);
}
var z = h(_t, "headingIdGenerator");
n(z, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
var ue2 = he("heading");
n(ue2, {
  displayName: "Attr<heading>",
  group: "Heading"
});
var H = fe("heading", (t) => {
  const e = t.get(z.key);
  return {
    content: "inline*",
    group: "block",
    defining: true,
    attrs: {
      id: {
        default: ""
      },
      level: {
        default: 1
      }
    },
    parseDOM: Dt.map((r) => ({
      tag: `h${r}`,
      getAttrs: (a) => {
        if (!(a instanceof HTMLElement))
          throw S(a);
        return { level: r, id: a.id };
      }
    })),
    toDOM: (r) => [
      `h${r.attrs.level}`,
      {
        ...t.get(ue2.key)(r),
        id: r.attrs.id || e(r)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: r }) => r === "heading",
      runner: (r, a, o) => {
        const s = a.depth;
        r.openNode(o, { level: s }), r.next(a.children), r.closeNode();
      }
    },
    toMarkdown: {
      match: (r) => r.type.name === "heading",
      runner: (r, a) => {
        r.openNode("heading", void 0, { depth: a.attrs.level }), at(r, a), r.closeNode();
      }
    }
  };
});
n(H.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
n(H.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
var pt = oe((t) => textblockTypeInputRule(/^(?<hashes>#+)\s$/, H.type(t), (e) => {
  var l, i;
  const r = ((i = (l = e.groups) == null ? void 0 : l.hashes) == null ? void 0 : i.length) || 0, a = t.get(L), { $from: o } = a.state.selection, s = o.node();
  if (s.type.name === "heading") {
    let d = Number(s.attrs.level) + Number(r);
    return d > 6 && (d = 6), { level: d };
  }
  return { level: r };
}));
n(pt, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
var L2 = re("WrapInHeading", (t) => (e) => (e ?? (e = 1), e < 1 ? setBlockType(w.type(t)) : setBlockType(H.type(t), { level: e })));
n(L2, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
var ge2 = re("DowngradeHeading", (t) => () => (e, r, a) => {
  const { $from: o } = e.selection, s = o.node();
  if (s.type !== H.type(t) || !e.selection.empty || o.parentOffset !== 0)
    return false;
  const l = s.attrs.level - 1;
  return l ? (r == null || r(
    e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
      ...s.attrs,
      level: l
    })
  ), true) : setBlockType(w.type(t))(e, r, a);
});
n(ge2, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
var ke2 = ge("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(L2.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(ge2.key);
    }
  }
});
n(ke2.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
n(ke2.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
var ye2 = he("blockquote");
n(ye2, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
var q = fe("blockquote", (t) => ({
  content: "block+",
  group: "block",
  defining: true,
  parseDOM: [{ tag: "blockquote" }],
  toDOM: (e) => ["blockquote", t.get(ye2.key)(e), 0],
  parseMarkdown: {
    match: ({ type: e }) => e === "blockquote",
    runner: (e, r, a) => {
      e.openNode(a).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "blockquote",
    runner: (e, r) => {
      e.openNode("blockquote").next(r.content).closeNode();
    }
  }
}));
n(q.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
n(q.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
var ct = oe((t) => wrappingInputRule(/^\s*>\s$/, q.type(t)));
n(ct, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
var he2 = re("WrapInBlockquote", (t) => () => wrapIn(q.type(t)));
n(he2, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
var fe2 = ge("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(he2.key);
    }
  }
});
n(fe2.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
n(fe2.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
var Ne = he("codeBlock", () => ({
  pre: {},
  code: {}
}));
n(Ne, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
var W2 = fe("code_block", (t) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: true,
  code: true,
  attrs: {
    language: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const r = t.get(Ne.key)(e);
    return [
      "pre",
      {
        ...r.pre,
        "data-language": e.attrs.language
      },
      ["code", r.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, r, a) => {
      const o = r.lang, s = r.value;
      e.openNode(a, { language: o }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, r) => {
      var a;
      e.addNode("code", void 0, ((a = r.content.firstChild) == null ? void 0 : a.text) || "", {
        lang: r.attrs.language
      });
    }
  }
}));
n(W2.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
n(W2.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
var ut = oe((t) => textblockTypeInputRule(/^```(?<language>[a-z]*)?[\s\n]$/, W2.type(t), (e) => {
  var r;
  return {
    language: ((r = e.groups) == null ? void 0 : r.language) ?? ""
  };
}));
n(ut, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
var Ie = re("CreateCodeBlock", (t) => (e = "") => setBlockType(W2.type(t), { language: e }));
n(Ie, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
var Et = re("UpdateCodeBlockLanguage", () => ({ pos: t, language: e } = { pos: -1, language: "" }) => (r, a) => t >= 0 ? (a == null || a(r.tr.setNodeAttribute(t, "language", e)), true) : false);
n(Et, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
var Ce = ge("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ie.key);
    }
  }
});
n(Ce.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
n(Ce.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
var Me = he("image");
n(Me, {
  displayName: "Attr<image>",
  group: "Image"
});
var v = fe("image", (t) => ({
  inline: true,
  group: "inline",
  selectable: true,
  draggable: true,
  marks: "",
  atom: true,
  defining: true,
  isolating: true,
  attrs: {
    src: { default: "" },
    alt: { default: "" },
    title: { default: "" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...t.get(Me.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, r, a) => {
      const o = r.url, s = r.alt, l = r.title;
      e.addNode(a, {
        src: o,
        alt: s,
        title: l
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, r) => {
      e.addNode("image", void 0, void 0, {
        title: r.attrs.title,
        url: r.attrs.src,
        alt: r.attrs.alt
      });
    }
  }
}));
n(v.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
n(v.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
var gt = re("InsertImage", (t) => (e = {}) => (r, a) => {
  if (!a)
    return true;
  const { src: o = "", alt: s = "", title: l = "" } = e, i = v.type(t).create({ src: o, alt: s, title: l });
  return i && a(r.tr.replaceSelectionWith(i).scrollIntoView()), true;
});
n(gt, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
var kt = re("UpdateImage", (t) => (e = {}) => (r, a) => {
  const o = findSelectedNodeOfType(r.selection, v.type(t));
  if (!o)
    return false;
  const { node: s, pos: l } = o, i = { ...s.attrs }, { src: d, alt: m, title: p } = e;
  return d !== void 0 && (i.src = d), m !== void 0 && (i.alt = m), p !== void 0 && (i.title = p), a == null || a(r.tr.setNodeMarkup(l, void 0, i).scrollIntoView()), true;
});
n(kt, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
var Pt = oe((t) => new InputRule(
  /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
  (e, r, a, o) => {
    const [s, l, i = "", d] = r;
    return s ? e.tr.replaceWith(a, o, v.type(t).create({ src: i, alt: l, title: d })) : null;
  }
));
n(Pt, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
var V = he("hardbreak", (t) => ({
  "data-type": "hardbreak",
  "data-is-inline": t.attrs.isInline
}));
n(V, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
var S2 = fe("hardbreak", (t) => ({
  inline: true,
  group: "inline",
  attrs: {
    isInline: {
      default: false
    }
  },
  selectable: false,
  parseDOM: [{ tag: "br" }, { tag: 'span[data-type="hardbreak"]', getAttrs: () => ({ isInline: true }) }],
  toDOM: (e) => e.attrs.isInline ? ["span", t.get(V.key)(e), " "] : ["br", t.get(V.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, r, a) => {
      var o;
      e.addNode(a, { isInline: !!((o = r.data) != null && o.isInline) });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, r) => {
      r.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
n(S2.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
n(S2.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
var be = re("InsertHardbreak", (t) => () => (e, r) => {
  var s;
  const { selection: a, tr: o } = e;
  if (!(a instanceof TextSelection))
    return false;
  if (a.empty) {
    const l = a.$from.node();
    if (l.childCount > 0 && ((s = l.lastChild) == null ? void 0 : s.type.name) === "hardbreak")
      return r == null || r(
        o.replaceRangeWith(a.to - 1, a.to, e.schema.node("paragraph")).setSelection(Selection.near(o.doc.resolve(a.to))).scrollIntoView()
      ), true;
  }
  return r == null || r(o.setMeta("hardbreak", true).replaceSelectionWith(S2.type(t).create()).scrollIntoView()), true;
});
n(be, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
var Le = ge("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(be.key);
    }
  }
});
n(Le.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
n(Le.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
var xe = he("hr");
n(xe, {
  displayName: "Attr<hr>",
  group: "Hr"
});
var F = fe("hr", (t) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", t.get(xe.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, r, a) => {
      e.addNode(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
n(F.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
n(F.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
var yt = oe((t) => new InputRule(
  /^(?:---|___\s|\*\*\*\s)$/,
  (e, r, a, o) => {
    const { tr: s } = e;
    return r[0] && s.replaceWith(a - 1, o, F.type(t).create()), s;
  }
));
n(yt, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
var ht = re("InsertHr", (t) => () => (e, r) => {
  if (!r)
    return true;
  const a = w.node.type(t).create(), { tr: o, selection: s } = e, { from: l } = s, i = F.type(t).create();
  if (!i)
    return true;
  const d = o.replaceSelectionWith(i).insert(l, a), m = Selection.findFrom(d.doc.resolve(l), 1, true);
  return m && r(d.setSelection(m).scrollIntoView()), true;
});
n(ht, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
var Se = he("bulletList");
n(Se, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
var O = fe("bullet_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: false
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...t.get(Se.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "false";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: false, spread: r.attrs.spread === "true" }).next(r.content).closeNode();
    }
  }
}));
n(O.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
n(O.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
var ft = oe((t) => wrappingInputRule(/^\s*([-+*])\s$/, O.type(t)));
n(ft, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
var Ae = re("WrapInBulletList", (t) => () => wrapIn(O.type(t)));
n(Ae, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
var we2 = ge("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ae.key);
    }
  }
});
n(we2.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
n(we2.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
var He = he("orderedList");
n(He, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
var T = fe("ordered_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1
    },
    spread: {
      default: false
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...t.get(He.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !!r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: true, start: 1, spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(T.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
n(T.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
var Nt = oe((t) => wrappingInputRule(
  /^\s*(\d+)\.\s$/,
  T.type(t),
  (e) => ({ order: Number(e[1]) }),
  (e, r) => r.childCount + r.attrs.order === Number(e[1])
));
n(Nt, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
var Be = re("WrapInOrderedList", (t) => () => wrapIn(T.type(t)));
n(Be, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
var Re = ge("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Be.key);
    }
  }
});
n(Re.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
n(Re.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
var ve = he("listItem");
n(ve, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
var M = fe("list_item", (t) => ({
  group: "listItem",
  content: "(paragraph|blockquote) block*",
  attrs: {
    label: {
      default: "•"
    },
    listType: {
      default: "bullet"
    },
    spread: {
      default: "true"
    }
  },
  defining: true,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...t.get(ve.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, r, a) => {
      const o = r.label != null ? `${r.label}.` : "•", s = r.label != null ? "ordered" : "bullet", l = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { label: o, listType: s, spread: l }), e.next(r.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, r) => {
      e.openNode("listItem", void 0, { spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(M.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
n(M.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
var Oe = re("SinkListItem", (t) => () => sinkListItem(M.type(t)));
n(Oe, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
var Te = re("LiftListItem", (t) => () => liftListItem(M.type(t)));
n(Te, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
var Ke = re("SplitListItem", (t) => () => splitListItem(M.type(t)));
n(Ke, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function $t(t) {
  return (e, r, a) => {
    const { selection: o } = e;
    if (!(o instanceof TextSelection))
      return false;
    const { empty: s, $from: l } = o;
    if (!s || l.parentOffset !== 0)
      return false;
    const i = l.node(-1);
    return i.type !== M.type(t) || i.firstChild !== l.node() || l.node(-2).childCount > 1 ? false : liftListItem(M.type(t))(e, r, a);
  };
}
var De = re("LiftFirstListItem", (t) => () => $t(t));
n(De, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
var _e = ge("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Ke.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Oe.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(Te.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (t) => {
      const e = t.get(je);
      return () => e.call(De.key);
    }
  }
});
n(_e.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
n(_e.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
var It = W("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: t }) => t === "text",
    runner: (t, e) => {
      t.addText(e.value);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "text",
    runner: (t, e) => {
      t.addNode("text", void 0, e.text);
    }
  }
}));
n(It, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
var Ee = he("html");
n(Ee, {
  displayName: "Attr<html>",
  group: "Html"
});
var Pe = fe("html", (t) => ({
  atom: true,
  group: "inline",
  inline: true,
  attrs: {
    value: {
      default: ""
    }
  },
  toDOM: (e) => {
    const r = document.createElement("span"), a = {
      ...t.get(Ee.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return r.textContent = e.attrs.value, ["span", a, e.attrs.value];
  },
  parseDOM: [{
    tag: 'span[data-type="html"]',
    getAttrs: (e) => ({
      value: e.dataset.value ?? ""
    })
  }],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, r, a) => {
      e.addNode(a, { value: r.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, r) => {
      e.addNode("html", void 0, r.attrs.value);
    }
  }
}));
n(Pe.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
n(Pe.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
var qt = [
  mt,
  me,
  w,
  z,
  ue2,
  H,
  V,
  S2,
  ye2,
  q,
  Ne,
  W2,
  xe,
  F,
  Me,
  v,
  Se,
  O,
  He,
  T,
  ve,
  M,
  ee,
  R,
  ae,
  $,
  se,
  x,
  de,
  B,
  Ee,
  Pe,
  It
].flat();
var Wt = [
  ct,
  ft,
  Nt,
  ut,
  yt,
  pt
].flat();
var Ft = [
  nt,
  ot,
  lt,
  st
];
var Vt = [
  pe,
  he2,
  L2,
  ge2,
  Ie,
  be,
  ht,
  gt,
  kt,
  Be,
  Ae,
  Oe,
  Ke,
  Te,
  De,
  te,
  le,
  ne,
  it,
  dt
];
var Ut = [
  fe2,
  Ce,
  Le,
  ke2,
  _e,
  Re,
  we2,
  ce,
  re2,
  ie,
  oe2
].flat();
var $e = ke("remarkAddOrderInList", () => () => (t) => {
  visit(t, "list", (e) => {
    if (e.ordered) {
      const r = e.start ?? 1;
      e.children.forEach((a, o) => {
        a.label = o + r;
      });
    }
  });
});
n($e.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
n($e.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
var qe = ke("remarkLineBreak", () => () => (t) => {
  const e = /[\t ]*(?:\r?\n|\r)/g;
  visit(t, "text", (r, a, o) => {
    if (!r.value || typeof r.value != "string")
      return;
    const s = [];
    let l = 0;
    e.lastIndex = 0;
    let i = e.exec(r.value);
    for (; i; ) {
      const m = i.index;
      l !== m && s.push({ type: "text", value: r.value.slice(l, m) }), s.push({ type: "break", data: { isInline: true } }), l = m + i[0].length, i = e.exec(r.value);
    }
    if (s.length > 0 && o && typeof a == "number")
      return l < r.value.length && s.push({ type: "text", value: r.value.slice(l) }), o.children.splice(a, 1, ...s), a + s.length;
  });
});
n(qe.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
n(qe.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
var We = ke("remarkInlineLink", () => remarkInlineLinks);
n(We.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
n(We.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
var Gt = (t) => !!t.children;
var jt = (t) => t.type === "html";
function zt(t, e) {
  return r(t, 0, null)[0];
  function r(a, o, s) {
    if (Gt(a)) {
      const l = [];
      for (let i = 0, d = a.children.length; i < d; i++) {
        const m = a.children[i];
        if (m) {
          const p = r(m, i, a);
          if (p)
            for (let y = 0, g = p.length; y < g; y++) {
              const C = p[y];
              C && l.push(C);
            }
        }
      }
      a.children = l;
    }
    return e(a, o, s);
  }
}
var Fe = ke("remarkHTMLTransformer", () => () => (t) => {
  zt(t, (e, r, a) => jt(e) ? ((a == null ? void 0 : a.type) === "root" && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
});
n(Fe.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
n(Fe.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
var Ve = ke("remarkMarker", () => () => (t, e) => {
  const r = (a) => e.value.charAt(a.position.start.offset);
  visit(t, (a) => ["strong", "emphasis"].includes(a.type), (a) => {
    a.marker = r(a);
  });
});
n(Ve.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
n(Ve.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
var Ct = ue(() => {
  let t = false;
  const e = new PluginKey("MILKDOWN_INLINE_NODES_CURSOR"), r = new Plugin({
    key: e,
    state: {
      init() {
        return false;
      },
      apply(a) {
        if (!a.selection.empty)
          return false;
        const o = a.selection.$from, s = o.nodeBefore, l = o.nodeAfter;
        return !!(s && l && s.isInline && !s.isText && l.isInline && !l.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (a, o) => t ? (t = false, requestAnimationFrame(() => {
          if (r.getState(a.state)) {
            const l = a.state.selection.from;
            o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", l));
          }
        }), true) : false,
        compositionstart: (a) => (r.getState(a.state) && (t = true), false),
        beforeinput: (a, o) => {
          if (r.getState(a.state) && o instanceof InputEvent && o.data && !t) {
            const l = a.state.selection.from;
            return o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", l)), true;
          }
          return false;
        }
      },
      decorations(a) {
        if (r.getState(a)) {
          const l = a.selection.$from.pos, i = document.createElement("span"), d = Decoration.widget(l, i, {
            side: -1
          }), m = document.createElement("span"), p = Decoration.widget(l, m);
          return setTimeout(() => {
            i.contentEditable = "true", m.contentEditable = "true";
          }), DecorationSet.create(a.doc, [d, p]);
        }
        return DecorationSet.empty;
      }
    }
  });
  return r;
});
n(Ct, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
var Mt = ue((t) => new Plugin({
  key: new PluginKey("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, r, a) => {
    if (!e.length)
      return;
    const [o] = e;
    if (!o)
      return;
    const [s] = o.steps;
    if (o.getMeta("hardbreak")) {
      if (!(s instanceof ReplaceStep))
        return;
      const { from: d } = s;
      return a.tr.setNodeMarkup(d, S2.type(t), void 0, []);
    }
    if (s instanceof AddMarkStep) {
      let d = a.tr;
      const { from: m, to: p } = s;
      return a.doc.nodesBetween(m, p, (y, g) => {
        y.type === S2.type(t) && (d = d.setNodeMarkup(g, S2.type(t), void 0, []));
      }), d;
    }
  }
}));
n(Mt, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
var Ue = h(["table", "code_block"], "hardbreakFilterNodes");
n(Ue, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
var bt = ue((t) => {
  const e = t.get(Ue.key);
  return new Plugin({
    key: new PluginKey("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (r, a) => {
      const o = r.getMeta("hardbreak"), [s] = r.steps;
      if (o && s) {
        const { from: l } = s, i = a.doc.resolve(l);
        let d = i.depth, m = true;
        for (; d > 0; )
          e.includes(i.node(d).type.name) && (m = false), d--;
        return m;
      }
      return true;
    }
  });
});
n(bt, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
var Lt = ue((t) => {
  const e = new PluginKey("MILKDOWN_HEADING_ID"), r = (a) => {
    if (a.composing)
      return;
    const o = t.get(z.key), s = a.state.tr.setMeta("addToHistory", false);
    let l = false;
    a.state.doc.descendants((i, d) => {
      if (i.type === H.type(t)) {
        if (i.textContent.trim().length === 0)
          return;
        const m = i.attrs, p = o(i);
        m.id !== p && (l = true, s.setMeta(e, true).setNodeMarkup(d, void 0, {
          ...m,
          id: p
        }));
      }
    }), l && a.dispatch(s);
  };
  return new Plugin({
    key: e,
    view: (a) => (r(a), {
      update: (o, s) => {
        o.state.doc.eq(s.doc) || r(o);
      }
    })
  });
});
n(Lt, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
var xt = ue((t) => {
  const e = (r) => {
    if (r.composing || !r.editable)
      return;
    const a = T.type(t), o = O.type(t), s = M.type(t), l = r.state, i = (p, y) => {
      let g = false;
      const C = `${y + 1}.`;
      return p.label !== C && (p.label = C, g = true), g;
    };
    let d = l.tr, m = false;
    l.doc.descendants((p, y, g, C) => {
      if (p.type === o) {
        const k = p.maybeChild(0);
        (k == null ? void 0 : k.type) === s && k.attrs.listType === "ordered" && (m = true, d.setNodeMarkup(y, a, { spread: "true" }), p.descendants((b, Ge, Qt, St) => {
          if (b.type === s) {
            const je2 = { ...b.attrs };
            i(je2, St) && (d = d.setNodeMarkup(Ge, void 0, je2));
          }
          return false;
        }));
      } else if (p.type === s && (g == null ? void 0 : g.type) === a) {
        const k = { ...p.attrs };
        let b = false;
        k.listType !== "ordered" && (k.listType = "ordered", b = true), (g == null ? void 0 : g.maybeChild(0)) && (b = i(k, C)), b && (d = d.setNodeMarkup(y, void 0, k), m = true);
      }
    }), m && r.dispatch(d.setMeta("addToHistory", false));
  };
  return new Plugin({
    key: new PluginKey("MILKDOWN_KEEP_LIST_ORDER"),
    view: (r) => (e(r), {
      update: (a) => {
        e(a);
      }
    })
  });
});
n(xt, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
var Jt = [
  Mt,
  Ue,
  bt,
  Ct,
  $e,
  We,
  qe,
  Fe,
  Ve,
  Lt,
  xt
].flat();
var cr = [qt, Wt, Ft, Vt, Ut, Jt].flat();

export {
  escapeStringRegexp,
  R,
  te,
  $,
  ne,
  x,
  le,
  B,
  w,
  H,
  q,
  W2 as W,
  v,
  F,
  O,
  T,
  M,
  cr
};
//# sourceMappingURL=chunk-AMUWVZB5.js.map
