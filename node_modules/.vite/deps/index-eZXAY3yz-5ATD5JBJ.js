import {
  A,
  G,
  linkTooltipAPI
} from "./chunk-AHBCO2RX.js";
import "./chunk-4WF63UED.js";
import {
  defIfNotExists
} from "./chunk-M2IBMVYD.js";
import "./chunk-6WIQVOVH.js";
import {
  boldIcon,
  c,
  clsx_default,
  codeIcon,
  html,
  italicIcon,
  linkIcon,
  strikethroughIcon,
  useEffect,
  useUpdate
} from "./chunk-457NNR5L.js";
import "./chunk-SFBMHIUF.js";
import {
  T,
  z
} from "./chunk-OQJUJ5UK.js";
import {
  $,
  B,
  R,
  le,
  ne,
  te,
  x
} from "./chunk-AMUWVZB5.js";
import {
  L,
  TextSelection,
  je
} from "./chunk-GFK4PW34.js";
import "./chunk-AP6IPAVY.js";
import "./chunk-DP4XHQAG.js";

// node_modules/@milkdown/crepe/lib/esm/index-eZXAY3yz.js
var toolbarComponent = ({
  ctx,
  hide,
  show,
  config
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const update = useUpdate();
  useEffect(() => {
    update();
  }, [show]);
  const onClick = (fn) => (e) => {
    e.preventDefault();
    ctx && fn(ctx);
    update();
  };
  const isActive = (mark) => {
    if (!ctx)
      return false;
    const view = ctx.get(L);
    const { state: { doc, selection } } = view;
    return doc.rangeHasMark(selection.from, selection.to, mark);
  };
  return html`<host>
    <button
      class=${clsx_default("toolbar-item", ctx && isActive($.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(je);
    commands.call(ne.key);
  })}
    >
      ${(_b = (_a = config == null ? void 0 : config.boldIcon) == null ? void 0 : _a.call(config)) != null ? _b : boldIcon}
    </button>
    <button
      class=${clsx_default("toolbar-item", ctx && isActive(R.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(je);
    commands.call(te.key);
  })}
    >
      ${(_d = (_c = config == null ? void 0 : config.italicIcon) == null ? void 0 : _c.call(config)) != null ? _d : italicIcon}
    </button>
    <button
      class=${clsx_default("toolbar-item", ctx && isActive(T.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(je);
    commands.call(z.key);
  })}
    >
      ${(_f = (_e = config == null ? void 0 : config.strikethroughIcon) == null ? void 0 : _e.call(config)) != null ? _f : strikethroughIcon}
    </button>
    <div class="divider"></div>
    <button
      class=${clsx_default("toolbar-item", ctx && isActive(x.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(je);
    commands.call(le.key);
  })}
    >
      ${(_h = (_g = config == null ? void 0 : config.codeIcon) == null ? void 0 : _g.call(config)) != null ? _h : codeIcon}
    </button>
    <button
      class=${clsx_default("toolbar-item", ctx && isActive(B.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const view = ctx2.get(L);
    const { selection } = view.state;
    if (isActive(B.type(ctx2))) {
      ctx2.get(linkTooltipAPI.key).removeLink(selection.from, selection.to);
      return;
    }
    ctx2.get(linkTooltipAPI.key).addLink(selection.from, selection.to);
    hide == null ? void 0 : hide();
  })}
    >
      ${(_j = (_i = config == null ? void 0 : config.linkIcon) == null ? void 0 : _i.call(config)) != null ? _j : linkIcon}
    </button>
  </host>`;
};
toolbarComponent.props = {
  ctx: Object,
  hide: Function,
  show: Boolean,
  config: Object
};
var ToolbarElement = c(toolbarComponent);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _tooltipProvider;
var _content;
var toolbar = G("CREPE_TOOLBAR");
var ToolbarView = class {
  constructor(ctx, view, config) {
    __privateAdd(this, _tooltipProvider);
    __privateAdd(this, _content);
    this.update = (view2, prevState) => {
      __privateGet(this, _tooltipProvider).update(view2, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _tooltipProvider).destroy();
      __privateGet(this, _content).remove();
    };
    this.hide = () => {
      __privateGet(this, _tooltipProvider).hide();
    };
    const content = new ToolbarElement();
    __privateSet(this, _content, content);
    __privateGet(this, _content).ctx = ctx;
    __privateGet(this, _content).hide = this.hide;
    __privateGet(this, _content).config = config;
    __privateSet(this, _tooltipProvider, new A({
      content: __privateGet(this, _content),
      debounce: 20,
      offset: 10,
      shouldShow(view2) {
        const { doc, selection } = view2.state;
        const { empty, from, to } = selection;
        const isEmptyTextBlock = !doc.textBetween(from, to).length && selection instanceof TextSelection;
        const isNotTextBlock = !(selection instanceof TextSelection);
        const activeElement = view2.dom.getRootNode().activeElement;
        const isTooltipChildren = content.contains(activeElement);
        const notHasFocus = !view2.hasFocus() && !isTooltipChildren;
        const isReadonly = !view2.editable;
        if (notHasFocus || isNotTextBlock || empty || isEmptyTextBlock || isReadonly)
          return false;
        return true;
      }
    }));
    __privateGet(this, _tooltipProvider).onShow = () => {
      __privateGet(this, _content).show = true;
    };
    __privateGet(this, _tooltipProvider).onHide = () => {
      __privateGet(this, _content).show = false;
    };
    this.update(view);
  }
};
_tooltipProvider = /* @__PURE__ */ new WeakMap();
_content = /* @__PURE__ */ new WeakMap();
defIfNotExists("milkdown-toolbar", ToolbarElement);
var defineFeature = (editor, config) => {
  editor.config((ctx) => {
    ctx.set(toolbar.key, {
      view: (view) => new ToolbarView(ctx, view, config)
    });
  }).use(toolbar);
};
export {
  defineFeature
};
//# sourceMappingURL=index-eZXAY3yz-5ATD5JBJ.js.map
