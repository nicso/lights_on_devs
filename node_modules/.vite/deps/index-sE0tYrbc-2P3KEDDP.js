import {
  imageBlockSchema
} from "./chunk-N6AXBBGF.js";
import "./chunk-CT72YLBL.js";
import {
  require_lodash
} from "./chunk-4WF63UED.js";
import {
  defIfNotExists,
  isInCodeBlock,
  isInList
} from "./chunk-M2IBMVYD.js";
import {
  require_lodash as require_lodash2
} from "./chunk-BKDY4GN5.js";
import {
  computePosition,
  flip,
  offset
} from "./chunk-6WIQVOVH.js";
import {
  bulletListIcon,
  c,
  codeIcon,
  dividerIcon,
  h1Icon,
  h2Icon,
  h3Icon,
  h4Icon,
  h5Icon,
  h6Icon,
  html,
  imageIcon,
  menuIcon,
  orderedListIcon,
  plusIcon,
  quoteIcon,
  tableIcon,
  textIcon,
  todoListIcon,
  useCallback,
  useEffect,
  useHost,
  useMemo,
  useRef,
  useState
} from "./chunk-457NNR5L.js";
import "./chunk-NU6SAH36.js";
import "./chunk-SFBMHIUF.js";
import {
  de
} from "./chunk-OQJUJ5UK.js";
import {
  F,
  H,
  M,
  O,
  T,
  W,
  q,
  w
} from "./chunk-AMUWVZB5.js";
import {
  DOMSerializer,
  L,
  NodeSelection,
  Plugin,
  PluginKey,
  TextSelection,
  browser,
  findParent,
  findParentNode,
  findWrapping,
  h,
  posToDOMRect,
  ue
} from "./chunk-GFK4PW34.js";
import "./chunk-AP6IPAVY.js";
import {
  __toESM
} from "./chunk-DP4XHQAG.js";

// node_modules/@milkdown/plugin-block/lib/index.es.js
var import_lodash = __toESM(require_lodash2());
var q2 = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var i = (s, t, e) => (q2(s, t, "read from private field"), e ? e.call(s) : t.get(s));
var a = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
};
var n = (s, t, e, r2) => (q2(s, t, "write to private field"), r2 ? r2.call(s, e) : t.set(s, e), e);
var Z = (s, t, e) => (q2(s, t, "access private method"), e);
function Y(s, t) {
  return Object.assign(s, {
    meta: {
      package: "@milkdown/plugin-block",
      ...t
    }
  }), s;
}
var mt = (s) => !findParent((e) => e.type.name === "table")(s);
var _ = h({ filterNodes: mt }, "blockConfig");
Y(_, {
  displayName: "Ctx<blockConfig>"
});
function bt(s, t, e) {
  var o2;
  if (!s.dom.parentElement)
    return null;
  try {
    const l2 = (o2 = s.posAtCoords({
      left: t.x,
      top: t.y
    })) == null ? void 0 : o2.inside;
    if (l2 == null || l2 < 0)
      return null;
    let c2 = s.state.doc.resolve(l2), h3 = s.state.doc.nodeAt(l2), d2 = s.nodeDOM(l2);
    const u2 = (z) => {
      const j = c2.depth >= 1 && c2.index(c2.depth) === 0;
      if (!(z || j))
        return;
      const S2 = c2.before(c2.depth);
      h3 = s.state.doc.nodeAt(S2), d2 = s.nodeDOM(S2), c2 = s.state.doc.resolve(S2), e(c2, h3) || u2(true);
    }, R2 = e(c2, h3);
    return u2(!R2), !d2 || !h3 ? null : { node: h3, $pos: c2, el: d2 };
  } catch {
    return null;
  }
}
var et = null;
function kt() {
  return et || (et = document.implementation.createHTMLDocument("title"));
}
var Ct = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
function yt(s, t) {
  const e = [];
  let { openStart: r2, openEnd: o2, content: l2 } = t;
  for (; r2 > 1 && o2 > 1 && l2.childCount === 1 && l2.firstChild.childCount === 1; ) {
    r2 -= 1, o2 -= 1;
    const p = l2.firstChild;
    e.push(
      p.type.name,
      p.attrs !== p.type.defaultAttrs ? p.attrs : null
    ), l2 = p.content;
  }
  const c2 = s.someProp("clipboardSerializer") || DOMSerializer.fromSchema(s.state.schema), h3 = kt(), d2 = h3.createElement("div");
  d2.appendChild(c2.serializeFragment(l2, { document: h3 }));
  let u2 = d2.firstChild, R2, z = 0;
  for (; u2 && u2.nodeType === 1 && (R2 = Ct[u2.nodeName.toLowerCase()]); ) {
    for (let p = R2.length - 1; p >= 0; p--) {
      const S2 = h3.createElement(R2[p]);
      for (; d2.firstChild; )
        S2.appendChild(d2.firstChild);
      d2.appendChild(S2), z++;
    }
    u2 = d2.firstChild;
  }
  u2 && u2.nodeType === 1 && u2.setAttribute(
    "data-pm-slice",
    `${r2} ${o2}${z ? ` -${z}` : ""} ${JSON.stringify(e)}`
  );
  const j = s.someProp("clipboardTextSerializer", (p) => p(t, s)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: d2, text: j };
}
var it = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
var ot = 20;
var D;
var H2;
var k;
var g;
var T2;
var m;
var U;
var st;
var C;
var A;
var y;
var v;
var F2;
var M2;
var P;
var B;
var K;
var w2;
var vt = class {
  constructor() {
    a(this, U);
    a(this, C);
    a(this, D, void 0);
    a(this, H2, void 0);
    a(this, k, void 0);
    a(this, g, void 0);
    a(this, T2, void 0);
    a(this, m, void 0);
    a(this, y, void 0);
    a(this, v, void 0);
    a(this, F2, void 0);
    a(this, M2, void 0);
    a(this, P, void 0);
    a(this, B, void 0);
    a(this, K, void 0);
    a(this, w2, void 0);
    n(this, H2, () => {
      if (!i(this, g))
        return null;
      const t = i(this, g), e = i(this, C, A);
      if (e && NodeSelection.isSelectable(t.node)) {
        const r2 = NodeSelection.create(e.state.doc, t.$pos.pos);
        return e.dispatch(e.state.tr.setSelection(r2)), e.focus(), n(this, k, r2), r2;
      }
      return null;
    }), n(this, k, null), n(this, g, null), n(this, T2, void 0), n(this, m, false), n(this, v, () => {
      var t;
      (t = i(this, y)) == null || t.call(this, { type: "hide" }), n(this, g, null);
    }), n(this, F2, (t) => {
      var e;
      n(this, g, t), (e = i(this, y)) == null || e.call(this, { type: "show", active: t });
    }), this.bind = (t, e) => {
      n(this, D, t), n(this, y, e);
    }, this.addEvent = (t) => {
      t.addEventListener("mousedown", i(this, M2)), t.addEventListener("mouseup", i(this, P)), t.addEventListener("dragstart", i(this, B));
    }, this.removeEvent = (t) => {
      t.removeEventListener("mousedown", i(this, M2)), t.removeEventListener("mouseup", i(this, P)), t.removeEventListener("dragstart", i(this, B));
    }, this.unBind = () => {
      n(this, y, void 0);
    }, n(this, M2, () => {
      var t;
      n(this, T2, (t = i(this, g)) == null ? void 0 : t.el.getBoundingClientRect()), i(this, H2).call(this);
    }), n(this, P, () => {
      if (!i(this, m)) {
        requestAnimationFrame(() => {
          var t;
          i(this, T2) && ((t = i(this, C, A)) == null || t.focus());
        });
        return;
      }
      n(this, m, false), n(this, k, null);
    }), n(this, B, (t) => {
      var o2;
      n(this, m, true);
      const e = i(this, C, A);
      if (!e)
        return;
      e.dom.dataset.dragging = "true";
      const r2 = i(this, k);
      if (t.dataTransfer && r2) {
        const l2 = r2.content();
        t.dataTransfer.effectAllowed = "copyMove";
        const { dom: c2, text: h3 } = yt(e, l2);
        t.dataTransfer.clearData(), t.dataTransfer.setData(it ? "Text" : "text/html", c2.innerHTML), it || t.dataTransfer.setData("text/plain", h3);
        const d2 = (o2 = i(this, g)) == null ? void 0 : o2.el;
        d2 && t.dataTransfer.setDragImage(d2, 0, 0), e.dragging = {
          slice: l2,
          move: true
        };
      }
    }), this.keydownCallback = (t) => (i(this, v).call(this), n(this, m, false), t.dom.dataset.dragging = "false", false), n(this, K, (0, import_lodash.default)((t, e) => {
      if (!t.editable)
        return;
      const r2 = t.dom.getBoundingClientRect(), o2 = r2.left + r2.width / 2;
      if (!(t.root.elementFromPoint(o2, e.clientY) instanceof Element)) {
        i(this, v).call(this);
        return;
      }
      const c2 = i(this, U, st);
      if (!c2)
        return;
      const h3 = bt(t, { x: o2, y: e.clientY }, c2);
      if (!h3) {
        i(this, v).call(this);
        return;
      }
      i(this, F2).call(this, h3);
    }, 200)), this.mousemoveCallback = (t, e) => (t.composing || !t.editable || i(this, K).call(this, t, e), false), this.dragoverCallback = (t, e) => {
      var r2;
      if (i(this, m)) {
        const o2 = (r2 = i(this, C, A)) == null ? void 0 : r2.dom.parentElement;
        if (!o2)
          return false;
        const l2 = o2.scrollHeight > o2.clientHeight, c2 = o2.getBoundingClientRect();
        if (l2) {
          if (o2.scrollTop > 0 && Math.abs(e.y - c2.y) < ot) {
            const u2 = o2.scrollTop > 10 ? o2.scrollTop - 10 : 0;
            return o2.scrollTop = u2, false;
          }
          const h3 = Math.round(t.dom.getBoundingClientRect().height);
          if (Math.round(o2.scrollTop + c2.height) < h3 && Math.abs(e.y - (c2.height + c2.y)) < ot) {
            const u2 = o2.scrollTop + 10;
            return o2.scrollTop = u2, false;
          }
        }
      }
      return false;
    }, this.dragenterCallback = (t) => {
      t.dragging && (n(this, m, true), t.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (t, e) => {
      const r2 = e.clientX, o2 = e.clientY;
      (r2 < 0 || o2 < 0 || r2 > window.innerWidth || o2 > window.innerHeight) && (n(this, g, null), i(this, w2).call(this, t));
    }, this.dropCallback = (t) => (i(this, w2).call(this, t), false), this.dragendCallback = (t) => {
      i(this, w2).call(this, t);
    }, n(this, w2, (t) => {
      n(this, m, false), t.dom.dataset.dragging = "false";
    });
  }
};
D = /* @__PURE__ */ new WeakMap(), H2 = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap(), T2 = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakSet(), st = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(_.key).filterNodes;
}, C = /* @__PURE__ */ new WeakSet(), A = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(L);
}, y = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap(), F2 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), w2 = /* @__PURE__ */ new WeakMap();
var X = h(new vt(), "blockService");
Y(_, {
  displayName: "Ctx<blockService>"
});
var G = h({}, "blockSpec");
Y(_, {
  displayName: "Ctx<blockSpec>"
});
var Q = ue((s) => {
  const t = new PluginKey("MILKDOWN_BLOCK"), e = s.get(X.key), r2 = s.get(G.key);
  return new Plugin({
    key: t,
    ...r2,
    props: {
      ...r2.props,
      handleDOMEvents: {
        drop: (o2) => e.dropCallback(o2),
        pointermove: (o2, l2) => e.mousemoveCallback(o2, l2),
        keydown: (o2) => e.keydownCallback(o2),
        dragover: (o2, l2) => e.dragoverCallback(o2, l2),
        dragleave: (o2, l2) => e.dragleaveCallback(o2, l2),
        dragenter: (o2) => e.dragenterCallback(o2),
        dragend: (o2) => e.dragendCallback(o2)
      }
    }
  });
});
Y(Q, {
  displayName: "Prose<block>"
});
var f;
var b;
var x;
var E;
var N;
var L2;
var O2;
var $;
var W2;
var nt;
var Bt = class {
  constructor(t) {
    a(this, W2);
    a(this, f, void 0);
    a(this, b, void 0);
    a(this, x, void 0);
    a(this, E, void 0);
    a(this, N, void 0);
    a(this, L2, void 0);
    a(this, O2, void 0);
    a(this, $, void 0);
    n(this, E, null), n(this, N, false), this.update = () => {
      requestAnimationFrame(() => {
        if (!i(this, N))
          try {
            Z(this, W2, nt).call(this), n(this, N, true);
          } catch {
          }
      });
    }, this.destroy = () => {
      var e, r2;
      (e = i(this, x)) == null || e.unBind(), (r2 = i(this, x)) == null || r2.removeEvent(i(this, f)), i(this, f).remove();
    }, this.show = (e) => {
      const r2 = e.el, o2 = i(this, b).get(L).dom, l2 = {
        ctx: i(this, b),
        active: e,
        editorDom: o2,
        blockDom: i(this, f)
      }, c2 = {
        contextElement: r2,
        getBoundingClientRect: () => i(this, O2) ? i(this, O2).call(this, l2) : r2.getBoundingClientRect()
      }, h3 = [flip()];
      if (i(this, L2)) {
        const d2 = i(this, L2).call(this, l2), u2 = offset(d2);
        h3.push(u2);
      }
      computePosition(c2, i(this, f), {
        placement: i(this, $) ? i(this, $).call(this, l2) : "left",
        middleware: h3
      }).then(({ x: d2, y: u2 }) => {
        Object.assign(i(this, f).style, {
          left: `${d2}px`,
          top: `${u2}px`
        }), i(this, f).dataset.show = "true";
      });
    }, this.hide = () => {
      i(this, f).dataset.show = "false";
    }, n(this, b, t.ctx), n(this, f, t.content), n(this, L2, t.getOffset), n(this, O2, t.getPosition), n(this, $, t.getPlacement), this.hide();
  }
  /// The context of current active node.
  get active() {
    return i(this, E);
  }
};
f = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), O2 = /* @__PURE__ */ new WeakMap(), $ = /* @__PURE__ */ new WeakMap(), W2 = /* @__PURE__ */ new WeakSet(), nt = function() {
  var r2;
  (r2 = i(this, b).get(L).dom.parentElement) == null || r2.appendChild(i(this, f));
  const e = i(this, b).get(X.key);
  e.bind(i(this, b), (o2) => {
    o2.type === "hide" ? (this.hide(), n(this, E, null)) : o2.type === "show" && (this.show(o2.active), n(this, E, o2.active));
  }), n(this, x, e), i(this, x).addEvent(i(this, f)), i(this, f).draggable = true;
};
var rt = [G, _, X, Q];
rt.key = G.key;
rt.pluginKey = Q.key;

// node_modules/@milkdown/plugin-slash/lib/index.es.js
var import_lodash2 = __toESM(require_lodash());
var P2 = (s, e, t) => {
  if (!e.has(s))
    throw TypeError("Cannot " + t);
};
var o = (s, e, t) => (P2(s, e, "read from private field"), t ? t.call(s) : e.get(s));
var a2 = (s, e, t) => {
  if (e.has(s))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(s) : e.set(s, t);
};
var r = (s, e, t, n2) => (P2(s, e, "write to private field"), n2 ? n2.call(s, t) : e.set(s, t), t);
var E2 = (s, e, t) => (P2(s, e, "access private method"), t);
function J(s) {
  const e = h({}, `${s}_SLASH_SPEC`), t = ue((i2) => {
    const m2 = i2.get(e.key);
    return new Plugin({
      key: new PluginKey(`${s}_SLASH`),
      ...m2
    });
  }), n2 = [e, t];
  return n2.key = e.key, n2.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${s}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${s}`
  }, n2;
}
var l;
var u;
var h2;
var d;
var f2;
var g2;
var S;
var H3;
var Q2 = class {
  constructor(e) {
    a2(this, S);
    a2(this, l, void 0);
    a2(this, u, void 0);
    a2(this, h2, void 0);
    a2(this, d, void 0);
    a2(this, f2, void 0);
    a2(this, g2, void 0);
    r(this, l, false), this.onShow = () => {
    }, this.onHide = () => {
    }, r(this, g2, (t, n2) => {
      var b2;
      const { state: i2, composing: m2 } = t, { selection: c2, doc: k2 } = i2, { ranges: y2 } = c2, x2 = Math.min(...y2.map((p) => p.$from.pos)), $2 = Math.max(...y2.map((p) => p.$to.pos)), w3 = n2 && n2.doc.eq(k2) && n2.selection.eq(c2);
      if (o(this, l) || ((b2 = t.dom.parentElement) == null || b2.appendChild(this.element), r(this, l, true)), m2 || w3)
        return;
      if (!o(this, d).call(this, t, n2)) {
        this.hide();
        return;
      }
      computePosition({
        getBoundingClientRect: () => posToDOMRect(t, x2, $2)
      }, this.element, {
        placement: "bottom-start",
        middleware: [flip(), offset(o(this, f2))]
      }).then(({ x: p, y: A2 }) => {
        Object.assign(this.element.style, {
          left: `${p}px`,
          top: `${A2}px`
        });
      }), this.show();
    }), this.update = (t, n2) => {
      (0, import_lodash2.default)(o(this, g2), o(this, u))(t, n2);
    }, this.getContent = (t, n2 = (i2) => i2.type.name === "paragraph") => {
      const { selection: i2 } = t.state, { empty: m2, $from: c2 } = i2, k2 = t.state.selection instanceof TextSelection, y2 = this.element.contains(document.activeElement), x2 = !t.hasFocus() && !y2, $2 = !t.editable, C2 = !findParentNode(n2)(t.state.selection);
      if (!(x2 || $2 || !m2 || !k2 || C2))
        return c2.parent.textBetween(Math.max(0, c2.parentOffset - 500), c2.parentOffset, void 0, "ï¿¼");
    }, this.destroy = () => {
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, r(this, u, e.debounce ?? 200), r(this, d, e.shouldShow ?? E2(this, S, H3)), r(this, h2, e.trigger ?? "/"), r(this, f2, e.offset);
  }
};
l = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), f2 = /* @__PURE__ */ new WeakMap(), g2 = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakSet(), H3 = function(e) {
  const t = this.getContent(e);
  if (!t)
    return false;
  const n2 = t.at(-1);
  return n2 ? Array.isArray(o(this, h2)) ? o(this, h2).includes(n2) : o(this, h2) === n2 : false;
};

// node_modules/@milkdown/crepe/lib/esm/index-sE0tYrbc.js
function clearRange(tr) {
  const { $from, $to } = tr.selection;
  const { pos: from } = $from;
  const { pos: to } = $to;
  tr = tr.deleteRange(from - $from.node().content.size, to);
  return tr;
}
function setBlockType(tr, nodeType, attrs = null) {
  const { from, to } = tr.selection;
  return tr.setBlockType(from, to, nodeType, attrs);
}
function wrapInBlockType(tr, nodeType, attrs = null) {
  const { $from, $to } = tr.selection;
  const range = $from.blockRange($to);
  const wrapping = range && findWrapping(range, nodeType, attrs);
  if (!wrapping)
    return null;
  return tr.wrap(range, wrapping);
}
function addBlockType(tr, nodeType, attrs = null) {
  const node = nodeType.createAndFill(attrs);
  if (!node)
    return null;
  return tr.replaceSelectionWith(node);
}
function clearContentAndSetBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    if (dispatch) {
      const tr = setBlockType(clearRange(state.tr), nodeType, attrs);
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function clearContentAndWrapInBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    const tr = wrapInBlockType(clearRange(state.tr), nodeType, attrs);
    if (!tr)
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function clearContentAndAddBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    const tr = addBlockType(clearRange(state.tr), nodeType, attrs);
    if (!tr)
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
var __typeError$2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$2 = (obj, member, value, setter) => (__accessCheck$2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _groups;
var _getGroupInstance;
var GroupBuilder = class {
  constructor() {
    __privateAdd$2(this, _groups, []);
    this.clear = () => {
      __privateSet$2(this, _groups, []);
      return this;
    };
    __privateAdd$2(this, _getGroupInstance, (group) => {
      const groupInstance = {
        group,
        addItem: (key, item) => {
          const data = { key, ...item };
          group.items.push(data);
          return groupInstance;
        },
        clear: () => {
          group.items = [];
          return groupInstance;
        }
      };
      return groupInstance;
    });
    this.addGroup = (key, label) => {
      const items = [];
      const group = {
        key,
        label,
        items
      };
      __privateGet$2(this, _groups).push(group);
      return __privateGet$2(this, _getGroupInstance).call(this, group);
    };
    this.getGroup = (key) => {
      const group = __privateGet$2(this, _groups).find((group2) => group2.key === key);
      if (!group)
        throw new Error(`Group with key ${key} not found`);
      return __privateGet$2(this, _getGroupInstance).call(this, group);
    };
    this.build = () => {
      return __privateGet$2(this, _groups);
    };
  }
};
_groups = /* @__PURE__ */ new WeakMap();
_getGroupInstance = /* @__PURE__ */ new WeakMap();
function getGroups(filter, config) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W;
  const groupBuilder = new GroupBuilder();
  groupBuilder.addGroup("text", (_a = config == null ? void 0 : config.slashMenuTextGroupLabel) != null ? _a : "Text").addItem("text", {
    label: (_b = config == null ? void 0 : config.slashMenuTextGroupLabel) != null ? _b : "Text",
    icon: (_d = (_c = config == null ? void 0 : config.slashMenuTextIcon) == null ? void 0 : _c.call(config)) != null ? _d : textIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(w.type(ctx));
      command(state, dispatch);
    }
  }).addItem("h1", {
    label: (_e = config == null ? void 0 : config.slashMenuH1Label) != null ? _e : "Heading 1",
    icon: (_g = (_f = config == null ? void 0 : config.slashMenuH1Icon) == null ? void 0 : _f.call(config)) != null ? _g : h1Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 1 });
      command(state, dispatch);
    }
  }).addItem("h2", {
    label: (_h = config == null ? void 0 : config.slashMenuH2Label) != null ? _h : "Heading 2",
    icon: (_j = (_i = config == null ? void 0 : config.slashMenuH2Icon) == null ? void 0 : _i.call(config)) != null ? _j : h2Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 2 });
      command(state, dispatch);
    }
  }).addItem("h3", {
    label: (_k = config == null ? void 0 : config.slashMenuH3Label) != null ? _k : "Heading 3",
    icon: (_m = (_l = config == null ? void 0 : config.slashMenuH3Icon) == null ? void 0 : _l.call(config)) != null ? _m : h3Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 3 });
      command(state, dispatch);
    }
  }).addItem("h4", {
    label: (_n = config == null ? void 0 : config.slashMenuH4Label) != null ? _n : "Heading 4",
    icon: (_p = (_o = config == null ? void 0 : config.slashMenuH4Icon) == null ? void 0 : _o.call(config)) != null ? _p : h4Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 4 });
      command(state, dispatch);
    }
  }).addItem("h5", {
    label: (_q = config == null ? void 0 : config.slashMenuH5Label) != null ? _q : "Heading 5",
    icon: (_s = (_r = config == null ? void 0 : config.slashMenuH5Icon) == null ? void 0 : _r.call(config)) != null ? _s : h5Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 5 });
      command(state, dispatch);
    }
  }).addItem("h6", {
    label: (_t = config == null ? void 0 : config.slashMenuH6Label) != null ? _t : "Heading 6",
    icon: (_v = (_u = config == null ? void 0 : config.slashMenuH6Icon) == null ? void 0 : _u.call(config)) != null ? _v : h6Icon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(H.type(ctx), { level: 6 });
      command(state, dispatch);
    }
  }).addItem("quote", {
    label: (_w = config == null ? void 0 : config.slashMenuQuoteLabel) != null ? _w : "Quote",
    icon: (_y = (_x = config == null ? void 0 : config.slashMenuQuoteIcon) == null ? void 0 : _x.call(config)) != null ? _y : quoteIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(q.type(ctx));
      command(state, dispatch);
    }
  }).addItem("divider", {
    label: (_z = config == null ? void 0 : config.slashMenuDividerLabel) != null ? _z : "Divider",
    icon: (_B = (_A = config == null ? void 0 : config.slashMenuDividerIcon) == null ? void 0 : _A.call(config)) != null ? _B : dividerIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndAddBlockType(F.type(ctx));
      command(state, dispatch);
    }
  });
  groupBuilder.addGroup("list", (_C = config == null ? void 0 : config.slashMenuListGroupLabel) != null ? _C : "List").addItem("bullet-list", {
    label: (_D = config == null ? void 0 : config.slashMenuBulletListLabel) != null ? _D : "Bullet List",
    icon: (_F = (_E = config == null ? void 0 : config.slashMenuBulletListIcon) == null ? void 0 : _E.call(config)) != null ? _F : bulletListIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(O.type(ctx));
      command(state, dispatch);
    }
  }).addItem("ordered-list", {
    label: (_G = config == null ? void 0 : config.slashMenuOrderedListLabel) != null ? _G : "Ordered List",
    icon: (_I = (_H = config == null ? void 0 : config.slashMenuOrderedListIcon) == null ? void 0 : _H.call(config)) != null ? _I : orderedListIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(T.type(ctx));
      command(state, dispatch);
    }
  }).addItem("todo-list", {
    label: (_J = config == null ? void 0 : config.slashMenuTaskListLabel) != null ? _J : "Todo List",
    icon: (_L = (_K = config == null ? void 0 : config.slashMenuTaskListIcon) == null ? void 0 : _K.call(config)) != null ? _L : todoListIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(M.type(ctx), { checked: false });
      command(state, dispatch);
    }
  });
  groupBuilder.addGroup("advanced", (_M = config == null ? void 0 : config.slashMenuAdvancedGroupLabel) != null ? _M : "Advanced").addItem("image", {
    label: (_N = config == null ? void 0 : config.slashMenuImageLabel) != null ? _N : "Image",
    icon: (_P = (_O = config == null ? void 0 : config.slashMenuImageIcon) == null ? void 0 : _O.call(config)) != null ? _P : imageIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndAddBlockType(imageBlockSchema.type(ctx));
      command(state, dispatch);
    }
  }).addItem("code", {
    label: (_Q = config == null ? void 0 : config.slashMenuCodeBlockLabel) != null ? _Q : "Code",
    icon: (_S = (_R = config == null ? void 0 : config.slashMenuCodeBlockIcon) == null ? void 0 : _R.call(config)) != null ? _S : codeIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const command = clearContentAndAddBlockType(W.type(ctx));
      command(state, dispatch);
    }
  }).addItem("table", {
    label: (_T = config == null ? void 0 : config.slashMenuTableLabel) != null ? _T : "Table",
    icon: (_V = (_U = config == null ? void 0 : config.slashMenuTableIcon) == null ? void 0 : _U.call(config)) != null ? _V : tableIcon,
    onRun: (ctx) => {
      const view = ctx.get(L);
      const { dispatch, state } = view;
      const tr = clearRange(state.tr);
      const table = de(ctx, 3, 3);
      tr.replaceSelectionWith(table);
      const { from } = tr.selection;
      const pos = from - table.nodeSize + 2;
      dispatch(tr);
      requestAnimationFrame(() => {
        const selection = NodeSelection.create(view.state.tr.doc, pos);
        dispatch(view.state.tr.setSelection(selection).scrollIntoView());
      });
    }
  });
  (_W = config == null ? void 0 : config.buildMenu) == null ? void 0 : _W.call(config, groupBuilder);
  let groups = groupBuilder.build();
  if (filter) {
    groups = groups.map((group) => {
      const items2 = group.items.filter((item) => item.label.toLowerCase().includes(filter.toLowerCase()));
      return {
        ...group,
        items: items2
      };
    }).filter((group) => group.items.length > 0);
  }
  const items = groups.flatMap((groups2) => groups2.items);
  items.forEach((item, index) => {
    Object.assign(item, { index });
  });
  groups.reduce((acc, group) => {
    const end = acc + group.items.length;
    Object.assign(group, {
      range: [acc, end]
    });
    return end;
  }, 0);
  return {
    groups,
    size: items.length
  };
}
var menuComponent = ({
  show,
  hide,
  ctx,
  filter,
  config
}) => {
  const { groups, size } = useMemo(() => getGroups(filter, config), [filter]);
  const host = useHost();
  const [hoverIndex, setHoverIndex] = useState(0);
  const root = useMemo(() => host.current.getRootNode(), [host]);
  const prevMousePosition = useRef({ x: -999, y: -999 });
  const onMouseMove = useCallback((e) => {
    const prevPos = prevMousePosition.current;
    if (!prevPos)
      return;
    const { x: x2, y: y2 } = e;
    prevPos.x = x2;
    prevPos.y = y2;
  }, []);
  useEffect(() => {
    if (size === 0 && show)
      hide == null ? void 0 : hide();
  }, [size, show]);
  const onHover = useCallback((index, after) => {
    setHoverIndex((prev) => {
      const next = typeof index === "function" ? index(prev) : index;
      after == null ? void 0 : after(next);
      return next;
    });
  }, []);
  const scrollToIndex = useCallback((index) => {
    const target = host.current.querySelector(`[data-index="${index}"]`);
    const scrollRoot = host.current.querySelector(".menu-groups");
    if (!target || !scrollRoot)
      return;
    scrollRoot.scrollTop = target.offsetTop - scrollRoot.offsetTop;
  }, []);
  const runByIndex = useCallback((index) => {
    const item = groups.flatMap((group) => group.items).at(index);
    if (item && ctx)
      item.onRun(ctx);
    hide == null ? void 0 : hide();
  }, [groups]);
  const onKeydown = useCallback((e) => {
    if (e.key === "Escape") {
      e.preventDefault();
      hide == null ? void 0 : hide();
      return;
    }
    if (e.key === "ArrowDown") {
      e.preventDefault();
      return onHover((index) => index < size - 1 ? index + 1 : index, scrollToIndex);
    }
    if (e.key === "ArrowUp") {
      e.preventDefault();
      return onHover((index) => index <= 0 ? index : index - 1, scrollToIndex);
    }
    if (e.key === "ArrowLeft") {
      e.preventDefault();
      return onHover((index) => {
        const group = groups.find((group2) => group2.range[0] <= index && group2.range[1] > index);
        if (!group)
          return index;
        const prevGroup = groups[groups.indexOf(group) - 1];
        if (!prevGroup)
          return index;
        return prevGroup.range[1] - 1;
      }, scrollToIndex);
    }
    if (e.key === "ArrowRight") {
      e.preventDefault();
      return onHover((index) => {
        const group = groups.find((group2) => group2.range[0] <= index && group2.range[1] > index);
        if (!group)
          return index;
        const nextGroup = groups[groups.indexOf(group) + 1];
        if (!nextGroup)
          return index;
        return nextGroup.range[0];
      }, scrollToIndex);
    }
    if (e.key === "Enter") {
      e.preventDefault();
      runByIndex(hoverIndex);
    }
  }, [hide, groups, hoverIndex]);
  const onMouseEnter = useCallback((index) => {
    return (e) => {
      const prevPos = prevMousePosition.current;
      if (!prevPos)
        return;
      const { x: x2, y: y2 } = e;
      if (x2 === prevPos.x && y2 === prevPos.y)
        return;
      onHover(index);
    };
  }, []);
  useEffect(() => {
    if (show)
      root.addEventListener("keydown", onKeydown, { capture: true });
    else root.removeEventListener("keydown", onKeydown, { capture: true });
    return () => {
      root.removeEventListener("keydown", onKeydown, { capture: true });
    };
  }, [show, onKeydown]);
  return html`
    <host onmousedown=${(e) => e.preventDefault()}>
      <nav class="tab-group">
        <ul>
          ${groups.map((group) => html`<li
              key=${group.key}
              onmousedown=${() => onHover(group.range[0], scrollToIndex)}
              class=${hoverIndex >= group.range[0] && hoverIndex < group.range[1] ? "selected" : ""}
            >
              ${group.label}
            </li>`)}
        </ul>
      </nav>
      <div class="menu-groups" onmousemove=${onMouseMove}>
        ${groups.map((group) => {
    return html`
            <div key=${group.key} class="menu-group">
              <h6>${group.label}</h6>
              <ul>
                ${group.items.map(
      (item) => html`<li
                    key=${item.key}
                    data-index=${item.index}
                    class=${hoverIndex === item.index ? "hover" : ""}
                    onmouseenter=${onMouseEnter(item.index)}
                    onmousedown=${() => {
        var _a;
        (_a = host.current.querySelector(`[data-index="${item.index}"]`)) == null ? void 0 : _a.classList.add("active");
      }}
                    onmouseup=${() => {
        var _a;
        (_a = host.current.querySelector(`[data-index="${item.index}"]`)) == null ? void 0 : _a.classList.remove("active");
        runByIndex(item.index);
      }}
                  >
                    ${item.icon}
                    <span>${item.label}</span>
                  </li>`
    )}
              </ul>
            </div>
          `;
  })}
      </div>
    </host>
  `;
};
menuComponent.props = {
  ctx: Object,
  config: Object,
  show: Boolean,
  filter: String,
  hide: Function
};
var MenuElement = c(menuComponent);
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _content$1;
var _slashProvider;
var _programmaticallyPos;
var menu = J("CREPE_MENU");
var menuAPI = h({
  show: () => {
  },
  hide: () => {
  }
}, "menuAPICtx");
defIfNotExists("milkdown-slash-menu", MenuElement);
function configureMenu(ctx, config) {
  ctx.set(menu.key, {
    view: (view) => new MenuView(ctx, view, config)
  });
}
var MenuView = class {
  constructor(ctx, view, config) {
    __privateAdd$1(this, _content$1);
    __privateAdd$1(this, _slashProvider);
    __privateAdd$1(this, _programmaticallyPos, null);
    this.update = (view2) => {
      __privateGet$1(this, _slashProvider).update(view2);
    };
    this.show = (pos) => {
      __privateSet$1(this, _programmaticallyPos, pos);
      __privateGet$1(this, _content$1).filter = "";
      __privateGet$1(this, _slashProvider).show();
    };
    this.hide = () => {
      __privateSet$1(this, _programmaticallyPos, null);
      __privateGet$1(this, _slashProvider).hide();
    };
    this.destroy = () => {
      __privateGet$1(this, _slashProvider).destroy();
      __privateGet$1(this, _content$1).remove();
    };
    __privateSet$1(this, _content$1, new MenuElement());
    __privateGet$1(this, _content$1).hide = this.hide;
    __privateGet$1(this, _content$1).ctx = ctx;
    __privateGet$1(this, _content$1).config = config;
    const self = this;
    __privateSet$1(this, _slashProvider, new Q2({
      content: __privateGet$1(this, _content$1),
      debounce: 20,
      shouldShow(view2) {
        if (isInCodeBlock(view2.state.selection) || isInList(view2.state.selection))
          return false;
        const currentText = this.getContent(view2, (node) => ["paragraph", "heading"].includes(node.type.name));
        if (currentText == null)
          return false;
        const pos = __privateGet$1(self, _programmaticallyPos);
        __privateGet$1(self, _content$1).filter = currentText.startsWith("/") ? currentText.slice(1) : currentText;
        if (typeof pos === "number") {
          if (view2.state.doc.resolve(pos).node() !== view2.state.doc.resolve(view2.state.selection.from).node()) {
            __privateSet$1(self, _programmaticallyPos, null);
            return false;
          }
          return true;
        }
        if (!currentText.startsWith("/"))
          return false;
        return true;
      },
      offset: 10
    }));
    __privateGet$1(this, _slashProvider).onShow = () => {
      __privateGet$1(this, _content$1).show = true;
    };
    __privateGet$1(this, _slashProvider).onHide = () => {
      __privateGet$1(this, _content$1).show = false;
    };
    this.update(view);
    ctx.set(menuAPI.key, {
      show: (pos) => this.show(pos),
      hide: () => this.hide()
    });
  }
};
_content$1 = /* @__PURE__ */ new WeakMap();
_slashProvider = /* @__PURE__ */ new WeakMap();
_programmaticallyPos = /* @__PURE__ */ new WeakMap();
var blockHandleComponent = ({
  onAdd,
  addIcon,
  handleIcon
}) => {
  const ref = useRef();
  useEffect(() => {
    var _a;
    (_a = ref.current) == null ? void 0 : _a.classList.remove("active");
  });
  const onMouseDown = (e) => {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    (_a = ref.current) == null ? void 0 : _a.classList.add("active");
  };
  const onMouseUp = (e) => {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    onAdd == null ? void 0 : onAdd();
    (_a = ref.current) == null ? void 0 : _a.classList.remove("active");
  };
  return html`
    <host>
      <div ref=${ref} onmousedown=${onMouseDown} onmouseup=${onMouseUp} class="operation-item">
        ${(addIcon == null ? void 0 : addIcon()) || plusIcon}
      </div>
      <div class="operation-item">
        ${(handleIcon == null ? void 0 : handleIcon()) || menuIcon}
      </div>
    </host>
  `;
};
blockHandleComponent.props = {
  show: Boolean,
  onAdd: Function,
  addIcon: Function,
  handleIcon: Function
};
var BlockHandleElement = c(blockHandleComponent);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _content;
var _provider;
var _ctx;
var BlockHandleView = class {
  constructor(ctx, config) {
    __privateAdd(this, _content);
    __privateAdd(this, _provider);
    __privateAdd(this, _ctx);
    this.update = () => {
      __privateGet(this, _provider).update();
    };
    this.destroy = () => {
      __privateGet(this, _provider).destroy();
      __privateGet(this, _content).remove();
    };
    this.onAdd = () => {
      const ctx2 = __privateGet(this, _ctx);
      const view = ctx2.get(L);
      if (!view.hasFocus())
        view.focus();
      const { state, dispatch } = view;
      const active = __privateGet(this, _provider).active;
      if (!active)
        return;
      const $pos = active.$pos;
      const pos = $pos.pos + active.node.nodeSize;
      let tr = state.tr.insert(pos, w.type(ctx2).create());
      tr = tr.setSelection(TextSelection.near(tr.doc.resolve(pos)));
      dispatch(tr.scrollIntoView());
      __privateGet(this, _provider).hide();
      ctx2.get(menuAPI.key).show(tr.selection.from);
    };
    __privateSet(this, _ctx, ctx);
    const content = new BlockHandleElement();
    __privateSet(this, _content, content);
    __privateGet(this, _content).onAdd = this.onAdd;
    __privateGet(this, _content).addIcon = config == null ? void 0 : config.handleAddIcon;
    __privateGet(this, _content).handleIcon = config == null ? void 0 : config.handleDragIcon;
    __privateSet(this, _provider, new Bt({
      ctx,
      content,
      getOffset: () => 16,
      getPlacement: ({ active, blockDom }) => {
        if (active.node.type.name === "heading")
          return "left";
        let totalDescendant = 0;
        active.node.descendants((node) => {
          totalDescendant += node.childCount;
        });
        const dom = active.el;
        const domRect = dom.getBoundingClientRect();
        const handleRect = blockDom.getBoundingClientRect();
        const style = window.getComputedStyle(dom);
        const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
        const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
        const height = domRect.height - paddingTop - paddingBottom;
        const handleHeight = handleRect.height;
        return totalDescendant > 2 || handleHeight < height ? "left-start" : "left";
      }
    }));
    this.update();
  }
};
_content = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_ctx = /* @__PURE__ */ new WeakMap();
defIfNotExists("milkdown-block-handle", BlockHandleElement);
function configureBlockHandle(ctx, config) {
  ctx.set(_.key, {
    filterNodes: (pos) => {
      const filter = findParent((node) => ["table", "blockquote"].includes(node.type.name))(pos);
      if (filter)
        return false;
      return true;
    }
  });
  ctx.set(rt.key, {
    view: () => new BlockHandleView(ctx, config)
  });
}
var defineFeature = (editor, config) => {
  editor.config((ctx) => configureBlockHandle(ctx, config)).config((ctx) => configureMenu(ctx, config)).use(menuAPI).use(rt).use(menu);
};
export {
  defineFeature
};
//# sourceMappingURL=index-sE0tYrbc-2P3KEDDP.js.map
