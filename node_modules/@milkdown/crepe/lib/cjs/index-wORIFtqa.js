'use strict';

var tooltip = require('@milkdown/kit/plugin/tooltip');
var state = require('@milkdown/kit/prose/state');
var index = require('./index-z6pe2alg.js');
var atomico = require('atomico');
var core = require('@milkdown/kit/core');
var commonmark = require('@milkdown/kit/preset/commonmark');
var clsx = require('clsx');
var linkTooltip = require('@milkdown/kit/component/link-tooltip');
var gfm = require('@milkdown/kit/preset/gfm');
var todoList = require('./todoList-Qb2JsRGC.js');

const toolbarComponent = ({
  ctx,
  hide,
  show,
  config
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const update = atomico.useUpdate();
  atomico.useEffect(() => {
    update();
  }, [show]);
  const onClick = (fn) => (e) => {
    e.preventDefault();
    ctx && fn(ctx);
    update();
  };
  const isActive = (mark) => {
    if (!ctx)
      return false;
    const view = ctx.get(core.editorViewCtx);
    const { state: { doc, selection } } = view;
    return doc.rangeHasMark(selection.from, selection.to, mark);
  };
  return atomico.html`<host>
    <button
      class=${clsx("toolbar-item", ctx && isActive(commonmark.strongSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(core.commandsCtx);
    commands.call(commonmark.toggleStrongCommand.key);
  })}
    >
      ${(_b = (_a = config == null ? void 0 : config.boldIcon) == null ? void 0 : _a.call(config)) != null ? _b : todoList.boldIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(commonmark.emphasisSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(core.commandsCtx);
    commands.call(commonmark.toggleEmphasisCommand.key);
  })}
    >
      ${(_d = (_c = config == null ? void 0 : config.italicIcon) == null ? void 0 : _c.call(config)) != null ? _d : todoList.italicIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(gfm.strikethroughSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(core.commandsCtx);
    commands.call(gfm.toggleStrikethroughCommand.key);
  })}
    >
      ${(_f = (_e = config == null ? void 0 : config.strikethroughIcon) == null ? void 0 : _e.call(config)) != null ? _f : todoList.strikethroughIcon}
    </button>
    <div class="divider"></div>
    <button
      class=${clsx("toolbar-item", ctx && isActive(commonmark.inlineCodeSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(core.commandsCtx);
    commands.call(commonmark.toggleInlineCodeCommand.key);
  })}
    >
      ${(_h = (_g = config == null ? void 0 : config.codeIcon) == null ? void 0 : _g.call(config)) != null ? _h : todoList.codeIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(commonmark.linkSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const view = ctx2.get(core.editorViewCtx);
    const { selection } = view.state;
    if (isActive(commonmark.linkSchema.type(ctx2))) {
      ctx2.get(linkTooltip.linkTooltipAPI.key).removeLink(selection.from, selection.to);
      return;
    }
    ctx2.get(linkTooltip.linkTooltipAPI.key).addLink(selection.from, selection.to);
    hide == null ? void 0 : hide();
  })}
    >
      ${(_j = (_i = config == null ? void 0 : config.linkIcon) == null ? void 0 : _i.call(config)) != null ? _j : todoList.linkIcon}
    </button>
  </host>`;
};
toolbarComponent.props = {
  ctx: Object,
  hide: Function,
  show: Boolean,
  config: Object
};
const ToolbarElement = atomico.c(toolbarComponent);

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _tooltipProvider, _content;
const toolbar = tooltip.tooltipFactory("CREPE_TOOLBAR");
class ToolbarView {
  constructor(ctx, view, config) {
    __privateAdd(this, _tooltipProvider);
    __privateAdd(this, _content);
    this.update = (view, prevState) => {
      __privateGet(this, _tooltipProvider).update(view, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _tooltipProvider).destroy();
      __privateGet(this, _content).remove();
    };
    this.hide = () => {
      __privateGet(this, _tooltipProvider).hide();
    };
    const content = new ToolbarElement();
    __privateSet(this, _content, content);
    __privateGet(this, _content).ctx = ctx;
    __privateGet(this, _content).hide = this.hide;
    __privateGet(this, _content).config = config;
    __privateSet(this, _tooltipProvider, new tooltip.TooltipProvider({
      content: __privateGet(this, _content),
      debounce: 20,
      offset: 10,
      shouldShow(view2) {
        const { doc, selection } = view2.state;
        const { empty, from, to } = selection;
        const isEmptyTextBlock = !doc.textBetween(from, to).length && selection instanceof state.TextSelection;
        const isNotTextBlock = !(selection instanceof state.TextSelection);
        const activeElement = view2.dom.getRootNode().activeElement;
        const isTooltipChildren = content.contains(activeElement);
        const notHasFocus = !view2.hasFocus() && !isTooltipChildren;
        const isReadonly = !view2.editable;
        if (notHasFocus || isNotTextBlock || empty || isEmptyTextBlock || isReadonly)
          return false;
        return true;
      }
    }));
    __privateGet(this, _tooltipProvider).onShow = () => {
      __privateGet(this, _content).show = true;
    };
    __privateGet(this, _tooltipProvider).onHide = () => {
      __privateGet(this, _content).show = false;
    };
    this.update(view);
  }
}
_tooltipProvider = new WeakMap();
_content = new WeakMap();
index.defIfNotExists("milkdown-toolbar", ToolbarElement);
const defineFeature = (editor, config) => {
  editor.config((ctx) => {
    ctx.set(toolbar.key, {
      view: (view) => new ToolbarView(ctx, view, config)
    });
  }).use(toolbar);
};

exports.defineFeature = defineFeature;
//# sourceMappingURL=index-wORIFtqa.js.map
