import { tooltipFactory, TooltipProvider } from '@milkdown/kit/plugin/tooltip';
import { TextSelection } from '@milkdown/kit/prose/state';
import { d as defIfNotExists } from './index-Jvxff1vU.js';
import { c, useUpdate, useEffect, html } from 'atomico';
import { editorViewCtx, commandsCtx } from '@milkdown/kit/core';
import { strongSchema, emphasisSchema, inlineCodeSchema, linkSchema, toggleStrongCommand, toggleEmphasisCommand, toggleInlineCodeCommand } from '@milkdown/kit/preset/commonmark';
import clsx from 'clsx';
import { linkTooltipAPI } from '@milkdown/kit/component/link-tooltip';
import { strikethroughSchema, toggleStrikethroughCommand } from '@milkdown/kit/preset/gfm';
import { C as boldIcon, D as italicIcon, E as strikethroughIcon, y as codeIcon, F as linkIcon } from './todoList-eAxCDaQj.js';

const toolbarComponent = ({
  ctx,
  hide,
  show,
  config
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const update = useUpdate();
  useEffect(() => {
    update();
  }, [show]);
  const onClick = (fn) => (e) => {
    e.preventDefault();
    ctx && fn(ctx);
    update();
  };
  const isActive = (mark) => {
    if (!ctx)
      return false;
    const view = ctx.get(editorViewCtx);
    const { state: { doc, selection } } = view;
    return doc.rangeHasMark(selection.from, selection.to, mark);
  };
  return html`<host>
    <button
      class=${clsx("toolbar-item", ctx && isActive(strongSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleStrongCommand.key);
  })}
    >
      ${(_b = (_a = config == null ? void 0 : config.boldIcon) == null ? void 0 : _a.call(config)) != null ? _b : boldIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(emphasisSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleEmphasisCommand.key);
  })}
    >
      ${(_d = (_c = config == null ? void 0 : config.italicIcon) == null ? void 0 : _c.call(config)) != null ? _d : italicIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(strikethroughSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleStrikethroughCommand.key);
  })}
    >
      ${(_f = (_e = config == null ? void 0 : config.strikethroughIcon) == null ? void 0 : _e.call(config)) != null ? _f : strikethroughIcon}
    </button>
    <div class="divider"></div>
    <button
      class=${clsx("toolbar-item", ctx && isActive(inlineCodeSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleInlineCodeCommand.key);
  })}
    >
      ${(_h = (_g = config == null ? void 0 : config.codeIcon) == null ? void 0 : _g.call(config)) != null ? _h : codeIcon}
    </button>
    <button
      class=${clsx("toolbar-item", ctx && isActive(linkSchema.type(ctx)) && "active")}
      onmousedown=${onClick((ctx2) => {
    const view = ctx2.get(editorViewCtx);
    const { selection } = view.state;
    if (isActive(linkSchema.type(ctx2))) {
      ctx2.get(linkTooltipAPI.key).removeLink(selection.from, selection.to);
      return;
    }
    ctx2.get(linkTooltipAPI.key).addLink(selection.from, selection.to);
    hide == null ? void 0 : hide();
  })}
    >
      ${(_j = (_i = config == null ? void 0 : config.linkIcon) == null ? void 0 : _i.call(config)) != null ? _j : linkIcon}
    </button>
  </host>`;
};
toolbarComponent.props = {
  ctx: Object,
  hide: Function,
  show: Boolean,
  config: Object
};
const ToolbarElement = c(toolbarComponent);

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _tooltipProvider, _content;
const toolbar = tooltipFactory("CREPE_TOOLBAR");
class ToolbarView {
  constructor(ctx, view, config) {
    __privateAdd(this, _tooltipProvider);
    __privateAdd(this, _content);
    this.update = (view, prevState) => {
      __privateGet(this, _tooltipProvider).update(view, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _tooltipProvider).destroy();
      __privateGet(this, _content).remove();
    };
    this.hide = () => {
      __privateGet(this, _tooltipProvider).hide();
    };
    const content = new ToolbarElement();
    __privateSet(this, _content, content);
    __privateGet(this, _content).ctx = ctx;
    __privateGet(this, _content).hide = this.hide;
    __privateGet(this, _content).config = config;
    __privateSet(this, _tooltipProvider, new TooltipProvider({
      content: __privateGet(this, _content),
      debounce: 20,
      offset: 10,
      shouldShow(view2) {
        const { doc, selection } = view2.state;
        const { empty, from, to } = selection;
        const isEmptyTextBlock = !doc.textBetween(from, to).length && selection instanceof TextSelection;
        const isNotTextBlock = !(selection instanceof TextSelection);
        const activeElement = view2.dom.getRootNode().activeElement;
        const isTooltipChildren = content.contains(activeElement);
        const notHasFocus = !view2.hasFocus() && !isTooltipChildren;
        const isReadonly = !view2.editable;
        if (notHasFocus || isNotTextBlock || empty || isEmptyTextBlock || isReadonly)
          return false;
        return true;
      }
    }));
    __privateGet(this, _tooltipProvider).onShow = () => {
      __privateGet(this, _content).show = true;
    };
    __privateGet(this, _tooltipProvider).onHide = () => {
      __privateGet(this, _content).show = false;
    };
    this.update(view);
  }
}
_tooltipProvider = new WeakMap();
_content = new WeakMap();
defIfNotExists("milkdown-toolbar", ToolbarElement);
const defineFeature = (editor, config) => {
  editor.config((ctx) => {
    ctx.set(toolbar.key, {
      view: (view) => new ToolbarView(ctx, view, config)
    });
  }).use(toolbar);
};

export { defineFeature };
//# sourceMappingURL=index-eZXAY3yz.js.map
