import { Editor, rootCtx, defaultValueCtx, editorViewOptionsCtx } from '@milkdown/kit/core';
import { commonmark } from '@milkdown/kit/preset/commonmark';
import { gfm } from '@milkdown/kit/preset/gfm';
import { history } from '@milkdown/kit/plugin/history';
import { indentConfig, indent } from '@milkdown/kit/plugin/indent';
import { getMarkdown } from '@milkdown/kit/utils';
import { clipboard } from '@milkdown/kit/plugin/clipboard';
import { trailing } from '@milkdown/kit/plugin/trailing';
import { createSlice } from '@milkdown/kit/ctx';

var CrepeFeature = /* @__PURE__ */ ((CrepeFeature2) => {
  CrepeFeature2["CodeMirror"] = "code-mirror";
  CrepeFeature2["ListItem"] = "list-item";
  CrepeFeature2["LinkTooltip"] = "link-tooltip";
  CrepeFeature2["Cursor"] = "cursor";
  CrepeFeature2["ImageBlock"] = "image-block";
  CrepeFeature2["BlockEdit"] = "block-edit";
  CrepeFeature2["Toolbar"] = "toolbar";
  CrepeFeature2["Placeholder"] = "placeholder";
  CrepeFeature2["Table"] = "table";
  return CrepeFeature2;
})(CrepeFeature || {});
const defaultFeatures = {
  ["cursor" /* Cursor */]: true,
  ["list-item" /* ListItem */]: true,
  ["link-tooltip" /* LinkTooltip */]: true,
  ["image-block" /* ImageBlock */]: true,
  ["block-edit" /* BlockEdit */]: true,
  ["placeholder" /* Placeholder */]: true,
  ["toolbar" /* Toolbar */]: true,
  ["code-mirror" /* CodeMirror */]: true,
  ["table" /* Table */]: true
};
async function loadFeature(feature, editor, config) {
  switch (feature) {
    case "code-mirror" /* CodeMirror */: {
      const { defineFeature } = await import('./index-I5dm1KsK.js');
      return defineFeature(editor, config);
    }
    case "list-item" /* ListItem */: {
      const { defineFeature } = await import('./index-J3c6JQEf.js');
      return defineFeature(editor, config);
    }
    case "link-tooltip" /* LinkTooltip */: {
      const { defineFeature } = await import('./index-HHuxH8Dm.js');
      return defineFeature(editor, config);
    }
    case "image-block" /* ImageBlock */: {
      const { defineFeature } = await import('./index-X2mjLDJS.js');
      return defineFeature(editor, config);
    }
    case "cursor" /* Cursor */: {
      const { defineFeature } = await import('./index-6JoGWH2I.js');
      return defineFeature(editor, config);
    }
    case "block-edit" /* BlockEdit */: {
      const { defineFeature } = await import('./index-sE0tYrbc.js');
      return defineFeature(editor, config);
    }
    case "placeholder" /* Placeholder */: {
      const { defineFeature } = await import('./index-CMGDOz11.js');
      return defineFeature(editor, config);
    }
    case "toolbar" /* Toolbar */: {
      const { defineFeature } = await import('./index-eZXAY3yz.js');
      return defineFeature(editor, config);
    }
    case "table" /* Table */: {
      const { defineFeature } = await import('./index-uThMsyF6.js');
      return defineFeature(editor, config);
    }
  }
}

const FeaturesCtx = createSlice([], "FeaturesCtx");
function configureFeatures(features) {
  return (ctx) => {
    ctx.inject(FeaturesCtx, features);
  };
}

var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _editor, _initPromise, _rootElement, _editable;
class Crepe {
  constructor({
    root,
    features = {},
    featureConfigs = {},
    defaultValue = ""
  }) {
    __privateAdd(this, _editor);
    __privateAdd(this, _initPromise);
    __privateAdd(this, _rootElement);
    __privateAdd(this, _editable, true);
    var _a;
    const enabledFeatures = Object.entries({
      ...defaultFeatures,
      ...features
    }).filter(([, enabled]) => enabled).map(([feature]) => feature);
    __privateSet(this, _rootElement, (_a = typeof root === "string" ? document.querySelector(root) : root) != null ? _a : document.body);
    __privateSet(this, _editor, Editor.make().config(configureFeatures(enabledFeatures)).config((ctx) => {
      ctx.set(rootCtx, __privateGet(this, _rootElement));
      ctx.set(defaultValueCtx, defaultValue);
      ctx.set(editorViewOptionsCtx, {
        editable: () => __privateGet(this, _editable)
      });
      ctx.update(indentConfig.key, (value) => ({
        ...value,
        size: 4
      }));
    }).use(commonmark).use(history).use(indent).use(trailing).use(clipboard).use(gfm));
    const promiseList = [];
    enabledFeatures.forEach((feature) => {
      const config = featureConfigs[feature];
      promiseList.push(
        loadFeature(feature, __privateGet(this, _editor), config)
      );
    });
    __privateSet(this, _initPromise, Promise.all(promiseList));
  }
  async create() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).create();
  }
  async destroy() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).destroy();
  }
  get editor() {
    return __privateGet(this, _editor);
  }
  setReadonly(value) {
    __privateSet(this, _editable, !value);
    return this;
  }
  getMarkdown() {
    return __privateGet(this, _editor).action(getMarkdown());
  }
}
_editor = new WeakMap();
_initPromise = new WeakMap();
_rootElement = new WeakMap();
_editable = new WeakMap();
Crepe.Feature = CrepeFeature;

export { Crepe, CrepeFeature };
//# sourceMappingURL=index.js.map
